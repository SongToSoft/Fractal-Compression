<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OpenCLTemplate</name>
    </assembly>
    <members>
        <member name="T:OpenCLTemplate.OpenCLRTBController">
            <summary>Class to help editing OpenCL code</summary>
        </member>
        <member name="M:OpenCLTemplate.OpenCLRTBController.#ctor(System.Windows.Forms.RichTextBox)">
            <summary>Constructor. Takes care of a Rich Text Box KeyUp event to paint things</summary>
            <param name="rTBOpenCL">RichTextBox to control</param>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.HelpIndentation">
            <summary>Help indentation?</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.NormalTextColor">
            <summary>Regular text color</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.NormalTextFont">
            <summary>Regular text font</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.CommentColor">
            <summary>Comments color</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.CommentTextFont">
            <summary>Comments font</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.OpenCLStrings">
            <summary>List of string structures to mark</summary>
        </member>
        <member name="M:OpenCLTemplate.OpenCLRTBController.rTB_KeyUp(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>KeyUp event handler</summary>
        </member>
        <member name="M:OpenCLTemplate.OpenCLRTBController.Update">
            <summary>Forces OpenCL RichTextBox to be updated</summary>
        </member>
        <member name="M:OpenCLTemplate.OpenCLRTBController.StartedUpdating(System.Windows.Forms.RichTextBox)">
            <summary>Stops updating text box while coloring text</summary>
            <param name="rTB">Rich text box to lock</param>
        </member>
        <member name="M:OpenCLTemplate.OpenCLRTBController.StoppedUpdating(System.Windows.Forms.RichTextBox)">
            <summary>Restarts updating text box</summary>
            <param name="rTB">Rich text box to unlock</param>
        </member>
        <member name="T:OpenCLTemplate.OpenCLRTBController.StringsToMark">
            <summary>Defines a structure of strings to mark</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.StringsToMark.Description">
            <summary>Description of string type</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.StringsToMark.StringsColor">
            <summary>Color to use for this string type</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.StringsToMark.StringsFont">
            <summary>Font to be used in this list of strings</summary>
        </member>
        <member name="F:OpenCLTemplate.OpenCLRTBController.StringsToMark.Strings">
            <summary>List of strings of this type</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg">
            <summary>Encapsulates Linear Algebra functions, especially symmetric positive definite matrices.
            WARNING: Do not exceed linear systems of size 23000</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.UseOpenCLIfAvailable">
            <summary>Use OpenCL?</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.SUBMATRIXSIZE">
            <summary>Submatrix size, based on maximum amount of workitems per workgroup</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelCholeskyDiagBlock">
            <summary>Cholesky factorization and inversion of a block</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelCholeskyComputePanel">
            <summary>Updates lower panel of Cholesky decomp</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelCholeskyForwardProp">
            <summary>Forwards updates to rest of the matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelFwdUpperBackSubs">
            <summary>First part of forward substitution</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelBkLowerBackSubs">
            <summary>First part of backsubstitution</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelFwdPropag">
            <summary>Forward propagation of values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelFwdPropag2">
            <summary>Forward propagation of values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelBackPropag">
            <summary>Backwards propagation of values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelBackPropag2">
            <summary>Backwards propagation of values (without __local)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelSymMatrVecMultiply">
            <summary>Matrix - vector product</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelComputeAtWA">
            <summary>Computes AtWA + lambda</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelComputeAinvHAt">
            <summary>Kernel to compute the last multiplication in the computation of A*inv(H)*A'</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelCopyBuffer">
            <summary>Copy buffer contents</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelLinearComb">
            <summary>Linear combination of vectors kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelMatrVecProd">
            <summary>Matrix vector product M*(alpha*v)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelTranspMatrVecProdW">
            <summary>Weighted matrix vector product transpose(M)*W*v</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelSymMatrMatrMultiply">
            <summary>Symmetric matrix matrix transpose multiply</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelRegularMatrTranspMatrProd">
            <summary>Regular A * B' matrix product</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelRegularMatrMatrProd">
            <summary>Regular A * B matrix product</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelInnerProd">
            <summary>Vector inner product</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelInPlaceSubtract">
            <summary>Performs in-place vector subtraction u = u-v</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelElemWiseAbs">
            <summary>In-place element wise absolute value</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelMatrVecProdSumVec">
            <summary>Matrix vector product M*(alpha*v) + beta*u</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelDiagVecProd">
            <summary>Diagonal vector product D*(alpha*v)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelDiagTranspMatProd">
            <summary>Diagonal matrix product D*(alpha*V)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelElemWiseProd">
            <summary>Element wise multiplication u .* u</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelElemWiseInv">
            <summary>Element wise inversion 1 ./ u</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelElemWiseInv2">
            <summary>Element wise square inversion 1 ./ (u.*u)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelClear">
            <summary>Kernel to set components of a vector to zero</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelPreSum">
            <summary>Pre-sum elements to prepare for coalescence</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelCoalLocalSum">
            <summary>Local reduced sum of vector components</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.kernelHasPositiveEntry">
            <summary>Checks if a vector has any positive entries</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.Init">
            <summary>Initializes CL kernels</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS">
            <summary>BLAS functions</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.LinearCombination(System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computer a linear combination alpha*u+beta*v. Puts answer in ans. Creates ans if it is null</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.LinearCombination(System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Computer a linear combination alpha*u+beta*v. Puts answer in ans. Creates ans if it is null</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.Dot(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes vector dot product</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <param name="temp">Temporary vector to store inner product</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.ElemWiseSquare(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Element-wise multiplication u .* u</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.ElemWiseInv(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Element-wise inversion 1 ./ u</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.ElemWiseInv2(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Element-wise inversion 1 ./ (u.*u)</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.SumVectorElements(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Sums the components of a vector using __local memory and coalesced access</summary>
            <param name="CLv">Vector whose components should be summed</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.SumMatrixElements(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix)">
            <summary>Sums the components of a vector using __local memory and coalesced access</summary>
            <param name="CLv">Matrix whose components should be summed</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.CopyVector(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Copies src vector contents to dst</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.CopyMatrix(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix)">
            <summary>Copies src vector contents to dst</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.HasPositiveEntries(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Returns true if v has any positive entries</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrVecProd(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes M*(alpha*v). Creates ans if it is null</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrVecProdSumVec(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes M*(alpha*v) + beta*u. Creates ans if it is null</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.DiagVecProd(OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes the Matrix-vector product alpha*D*u</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.DiagTranspMatProd(OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Computes the Matrix-matrix transpose product alpha*D*transpose(V)</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MultiplyNoCL(OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Symmetric positive definite product with vector, Msym*v. resp gets constructed if ==null </summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.SymPosDefSymMatrVecMultiply(OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Symmetric positive definite product with vector, Msym*v. resp gets constructed if ==null </summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.ComputeAinvHTranspA(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@,System.Boolean)">
            <summary>Computes A*inv(H)*A' and stores result in ans</summary>
            <param name="A">A matrix, mxn</param>
            <param name="H">H matrix, nxn</param>
            <param name="ans">answer, mxm</param>
            <param name="temp">Temporary matrix for the operation, size nxm</param>
            <param name="refine">Refine linear system solution?</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrTranspMatrProd(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@)">
            <summary>Computes transpose(A)*A</summary>
            <param name="A">Original matrix</param>
            <param name="lambda">Regularization term</param>
            <param name="AtA">Answer, A transpose times A</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.SymPosDefMatrMatrMultiply(OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Symmetric positive definite product with matrix transpose, Msym*At. ans gets constructed if ==null </summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrTranspMatrProd(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@)">
            <summary>Computes transpose(A)*A using weights W</summary>
            <param name="A">Original matrix</param>
            <param name="W">Measurement weight vector</param>
            <param name="lambda">Regularization term</param>
            <param name="AtA">Answer, A transpose times A</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrTranspMatrProd(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Computes A*B' = A*transpose(B) and stores result in ans</summary>
            <param name="A">Matrix A</param>
            <param name="B">Matrix B</param>
            <param name="ans">Answer. If null, gets created.</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrMatrProd(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Computes A*B and stores result in ans</summary>
            <param name="A">Matrix A</param>
            <param name="B">Matrix B</param>
            <param name="ans">Answer. If null, gets created.</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.AuxLeastSquaresAtAnoCL(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@)">
            <summary>Computes transpose(A)*A and transpose(A)*b weighted by W</summary>
            <param name="A">Original matrix</param>
            <param name="W">Measurement weight vector</param>
            <param name="lambda">Regularization term</param>
            <param name="AtA">Answer, A transpose times A</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.AuxLSAtACL(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@)">
            <summary>Computes transpose(A)*A and transpose(A)*b weighted by W using OpenCL. Lambda is regularization term</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrTraspVecMult(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes transpose(A)*diag(W)*b*alpha</summary>
            <param name="A">Original matrix</param>
            <param name="b">Vector to multiply</param>
            <param name="W">Measurement weight vector</param>
            <param name="ans">Answer. If null, gets created</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.BLAS.MatrTraspVecMult(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Single,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes transpose(A)*diag(W)*b*alpha</summary>
            <param name="A">Original matrix</param>
            <param name="b">Vector to multiply</param>
            <param name="W">Measurement weight vector</param>
            <param name="alpha">Multiplication constant</param>
            <param name="ans">Answer. If null, gets created</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix">
            <summary>Encapsulates functions to create a symmetric, positive definite matrix</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.#ctor(System.Int32)">
            <summary>Constructor.</summary>
            <param name="n">Number of matrix rows (n x n)</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.#ctor(System.Single[])">
            <summary>Constructor.</summary>
            <param name="vals">Matrix elements. Length should be n*(n+1)/2 where matrix is nxn</param>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.N">
            <summary>Matrix dimension</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Values">
            <summary>Matrix values</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.ToString">
            <summary>Returns a string representing this instance</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.IsCholeskyFactorized">
            <summary>Was the matrix cholesky factorized since last update?</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.cholDec">
            <summary>Cholesky factorization</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.ComputeCholesky">
            <summary>Computes Cholesky factorization of a matrix</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NoCLCholesky">
            <summary>Naive computation of the Cholesky factorization for very small systems or systems without OpenCL</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CheckDecomposition">
            <summary>DEBUG function. Returns true if Cholesky decomposition succeeded to 10*float.Epsilon precision</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.invL11">
            <summary>Submatrix inverse</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLinvl11">
            <summary>Submatrix inverse</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLcholDec">
            <summary>Cholesky decomposition in Device memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLValues">
            <summary>Copy of values of this matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.IsMatrixInClMemoryUpdated">
            <summary>Is matrix in OpenCL memory updated?</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLprevVals">
            <summary>Cholesky elements computed in previous step</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLoffSet">
            <summary>Offsets to perform calculations</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLb">
            <summary>B variable during back/forward subst</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLy">
            <summary>Y variable during back/forward subst</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLn">
            <summary>Size of matrix in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.vecMx">
            <summary>Vector to hold M*current solution</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.vecResidues">
            <summary>Vector to hold residues</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.vecResiduesAbs">
            <summary>Vector to hold residues absolute values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.vecDeltax">
            <summary>Vector to hold refinement</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.matMx">
            <summary>Vector to hold M*current solution</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.matResidues">
            <summary>Vector to hold residues</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.matResiduesAbs">
            <summary>Vector to hold residues absolute values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.matDeltax">
            <summary>Vector to hold refinement</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.CLBlockCholesky">
            <summary>Cholesky decomposition using OpenCL with Blocks</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.LinearSolve(System.Single[])">
            <summary>Solves system Ax = b and returns x</summary>
            <param name="b">b vector</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.LinearSolve(System.Single[],System.Boolean)">
            <summary>Solves system Ax = b and returns x</summary>
            <param name="b">b vector</param>
            <param name="refine">Refine solution? Recommended: true</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.LinearSolve(System.Single[0:,0:],System.Boolean)">
            <summary>Solves system Ax = b and returns x, where b is a right hand side matrix</summary>
            <param name="b">b vector</param>
            <param name="refine">Refine solution? Recommended: true</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.LinearSolve(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,System.Boolean,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Solves system A*invHAt = Mt and returns invHAt solving system per column. Refine may considerably slow the method.</summary>
            <param name="M">Right-hand-size of linear system</param>
            <param name="refine">Refine solution? Recommended: true</param>
            <param name="invHAt">Answer A*invHAt</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.LinearSolve(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Boolean,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Solves system Ax = b and returns x</summary>
            <param name="CLbb">b vector</param>
            <param name="refine">Refine solution? Recommended: true</param>
            <param name="resp">Holds answer</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.linsolve(System.Single[],OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Solves system Ax = b and returns x</summary>
            <param name="bb">b vector</param>
            <param name="resp">Solution</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.LinsolveCLMatrix(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Backsubstitutes to solve a linear system with a matrix right hand size</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.linsolveMatrix(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@)">
            <summary>Solves system Ax = b' and returns x</summary>
            <param name="bb">b Matrix</param>
            <param name="resp">Answer</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Determinant">
            <summary>Retrieves the Determinant of this matrix</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Dot(System.Single[],System.Single[])">
            <summary>Dot product</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.MultiplyCL(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Symmetric positive definite product with vector, Msym*v. resp gets constructed if ==null </summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Write(System.String)">
            <summary>Writes this matrix to file in Octave format</summary>
            <param name="file">File to write to</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Identity(System.Int32)">
            <summary>Returns the identity matrix</summary>
            <param name="n">Matrix dimension nxn</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonLinearLS(OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.ComputeResidueGrad,System.Single[],System.Int32,System.Int32,System.Double@)">
            <summary>Computes nonlinear least squares using user functions to evaluate residues and their gradients</summary>
            <param name="f">Function that computes residues [m] and their gradients [grad r1; grad r2] m x n (each gradient in one line) [i,j] = gradR[i,j]</param>
            <param name="x">Intial guess</param>
            <param name="m">Number of residue equations</param>
            <param name="maxiter">Maximum number of iterations</param>
            <param name="err">Adjustment error</param>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.getN">
            <summary>Gets matrix dimension</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Rows">
            <summary>Nuumber of rows</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Cols">
            <summary>Number of columns</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.Item(System.Int32,System.Int32)">
            <summary>Access matrix elements</summary>
            <param name="i">Row index of element to access</param>
            <param name="j">Column index of element to access</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.ComputeResidueGrad">
            <summary>Delegate to compute residues and gradients based on current estimate x [n]. Returns residues r [m] and gradients gradR [m , n], j-th component
            of gradient of residue r[i] = [i,j] = gradR[i,j] </summary>
            <param name="x">Current estimate</param>
            <param name="r">Residues</param>
            <param name="gradR">Gradient of residue functions</param>
            <param name="ComputeGrads">Compute gradients?</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem">
            <summary>Nonlinear optimization problem</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunctions">
            <summary>List of residue functions of this nonlinear optimization problem</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ComputeResidueGrad(System.Single[],System.Single[]@,System.Single[0:,0:]@,System.Boolean)">
            <summary>Computes residues and gradients of residue functions of this nonlinear optimization problem</summary>
            <param name="x">Global optimization vector</param>
            <param name="r">Residues</param>
            <param name="gradR">Gradient</param>
            <param name="ComputeGrads">Compute gradients?</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.Solve(System.Single[],System.Int32)">
            <summary>Solves this nonlinear optimization problem</summary>
            <param name="x">Global optimization vector, initial guess</param>
            <param name="MAXITER">Maximum number of iterations</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunction">
            <summary>Generic residue function of type F(x) - y</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunction.y">
            <summary>Desired value of this function</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunction.X">
            <summary>Current values of local variables</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunction.GlobalIndex">
            <summary>Mapping of local indexes to global indexes</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunction.ComputeResidueGradient(System.Single[],System.Boolean,System.Single[]@)">
            <summary>Computes residue and gradient of this Residue function</summary>
            <param name="x">Global optimization variable</param>
            <param name="ComputeGrad">Compute gradient?</param>
            <param name="Gradient">Global gradient of this function</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunction.InitY(System.Single[])">
            <summary>For simulation purposes, compute local Y as a function of a global optimization variable</summary>
            <param name="x">Optimization variable</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.ResidueFunction.F(System.Boolean,System.Single[]@)">
            <summary>Computes function value and gradient using local information</summary>
            <param name="ComputeGrad">Compute gradient?</param>
            <param name="Gradient">Local gradient output</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.SampleResidueFunctions">
            <summary>Example residue functions</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.SampleResidueFunctions.ResidueExp">
            <summary>Sample residues</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.SampleResidueFunctions.ResidueExp.#ctor(System.Single)">
            <summary>Constructor</summary>
            <param name="T">Desired function value</param>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.SampleResidueFunctions.ResidueExp.t">
            <summary>Desired function value</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix.NonlinearOptimizProblem.SampleResidueFunctions.ResidueExp.F(System.Boolean,System.Single[]@)">
            <summary>Function F</summary>
            <param name="ComputeGrad">Compute gradient?</param>
            <param name="Gradient">Returns gradient</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector">
            <summary>Functions to create and manipulate vectors</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.Values">
            <summary>Vetor values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.CLValues">
            <summary>Vetor values in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.CLCoef">
            <summary>Vetor coefficient for combinations</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.CLn">
            <summary>Vector dimension in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.CLresps">
            <summary>Partial sums in CL memory</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.#ctor(System.Single[])">
            <summary>OpenCL vector constructor</summary>
            <param name="Vals">Vector elements</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.#ctor(OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix)">
            <summary>Creates vector from M elements sequentially</summary>
            <param name="symM">Symmetric matrix to use</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.Sum">
            <summary>Returns the sum of components of this vector</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.Norm(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes the Euclidean norm of this  vector</summary>
            <param name="temp">Holds temporary operations</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.NormSquared(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@)">
            <summary>Computes square of the Euclidean norm of this  vector</summary>
            <param name="temp">Holds temporary operations</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.HasPositiveEntries">
            <summary>Returns true if this vector has any positive entries</summary>
            <returns></returns>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.ReadFromDevice">
            <summary>Reads from OpenCL if using OpenCL</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.SetValues(System.Single[])">
            <summary>Set vector values</summary>
            <param name="v">Values to copy from</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.Write(System.String)">
            <summary>Writes contents of this vector to disk</summary>
            <param name="file"></param>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector.Length">
            <summary>Vector dimension</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix">
            <summary>Generic matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.Values">
            <summary>Vector representation of the matrix values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.CLValues">
            <summary>Matrix values in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.CLCoef">
            <summary>Coefficient for combinations</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.CLDim">
            <summary>Matrix dimensions in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.CLn">
            <summary>Vector dimension in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.CLresps">
            <summary>Partial sums in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.nRows">
            <summary>Number of rows</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.nCols">
            <summary>Number of columns</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.#ctor(System.Single[0:,0:])">
            <summary>New matrix constructor</summary>
            <param name="Vals">Matrix values</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.SetValues(System.Single[0:,0:])">
            <summary>Sets values for this matrix</summary>
            <param name="Vals">New values</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.Sum">
            <summary>Returns the sum of components of this matrix</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.Write(System.String)">
            <summary>Writes this matrix to file in Octave format</summary>
            <param name="file">File to write to</param>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.Rows">
            <summary>Matrix dimension</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.Cols">
            <summary>Matrix dimension</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix.Item(System.Int32,System.Int32)">
            <summary>Retrieve matrix elements</summary>
            <param name="i">Row</param>
            <param name="j">Column</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag">
            <summary>Diagonal matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag.Values">
            <summary>Values of diagonal elements</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag.CLValues">
            <summary>Values of diagonal elements in OpenCL memory</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag.#ctor(System.Single[])">
            <summary>OpenCL diagonal matrix constructor</summary>
            <param name="Vals">Main diagonal elements</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag.#ctor(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Creates the diagonal matrix D(v) with elements associated to those of vector v. Uses the same objects.</summary>
            <param name="v">Reference vector</param>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag.Rows">
            <summary>Matrix dimension</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatLinalg.floatDiag.Cols">
            <summary>Matrix dimension</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatLinalg.LinalgSrc.srcVecSum">
            <summary>Coalesced vector sum kernels</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization">
            <summary>Encapsulates optimization techniques based on Newton methods</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization">
            <summary>Unconstrained minimization driver</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Solve(System.Single[],OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.C2Function,System.Int32@)">
            <summary>Computes the unconstrained minimum of function F in x0.Length dimensions</summary>
            <param name="x0">Start point. Problem dimension is assumed to be x0.Length</param>
            <param name="F">Function to minimize</param>
            <param name="iters">Number of iterations used to solve the problem</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Solve(System.Single[],OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.C2Function,System.Single[0:,0:],System.Single[],System.Int32@)">
            <summary>Computes the unconstrained minimum of function F in x0.Length dimensions subject to equality constraint Ax=b</summary>
            <param name="x0">Start point. Problem dimension is assumed to be x0.Length</param>
            <param name="F">Function to minimize</param>
            <param name="A">Equality constraint matrix</param>
            <param name="b">Equality constraint rhs</param>            
            <param name="iters">Number of iterations used to solve the problem</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Solve(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.C2Function,System.Int32@,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Computes the unconstrained minimum of function F in x0.Length dimensions</summary>
            <param name="CLx">Solution x and initial guess</param>
            <param name="F">Function to be minimized</param>
            <param name="iters">Number of iterations</param>
            <param name="HessF">Holder of hessian of F</param>
            <param name="gradF">Holder of gradient of F</param>
            <param name="temp">Temporary vector of dimension n</param>
            <param name="deltaX">X search direction</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Solve(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.C2Function,System.Int32@,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Computes the unconstrained minimum of function F in x0.Length dimensions</summary>
            <param name="CLx">Solution x and initial guess</param>
            <param name="F">Function to be minimized</param>
            <param name="iters">Number of iterations</param>
            <param name="HessF">Holder of hessian of F</param>
            <param name="gradF">Holder of gradient of F</param>
            <param name="temp">Temporary vector of dimension n</param>
            <param name="deltaX">X search direction</param>
            <param name="A">Equality constraint matrix</param>
            <param name="b">Equality constraint rhs</param>
            <param name="AinvHAt">Holder of A*inv(H)*A'</param>
            <param name="tempAinvMatrix">Temporary matrix for computation of inv(H)*A'</param>
            <param name="temp2">Temporary vector of length n</param>
            <param name="AinvHrhs">Temporary vector</param>
            <param name="rPri">Primal residual</param>
            <param name="tempC">Temporary vector of length C</param>
            <param name="CLDeltaNu">Search direction in Nu</param>
            <param name="Atnu">A times nu</param>
            <param name="onesC">Vector of ones of dimension C</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.BackTrack(OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.C2Function,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@)">
            <summary>Line search algorithm</summary>
            <param name="f">Function to be searched</param>
            <param name="x">Current point</param>
            <param name="deltaX">Search direction</param>
            <param name="gradF">Gradient of F</param>
            <param name="temp">Temporary vector to store current direction</param>
            <param name="HessF">Hessian of F</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Config">
            <summary>Configuration parameters (v. Boyd's Convex Optimization)</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Config.alpha">
            <summary>Backtrack line search alpha parameter</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Config.beta">
            <summary>Backtrack line search beta parameter</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Config.eps">
            <summary>Unconstrained minimization precision</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.Config.MaxIterations">
            <summary>Maximum number of iterations</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.UnconstrainedMinimization.C2Function">
            <summary>Function to be used in unconstrained minimization method. Should compute function value and search direction if requested
            (i.e., probably solve a Newton system)</summary>
            <param name="CLx">Current function point</param>
            <param name="ComputeGradHess">Compute gradient and hessian?</param>
            <param name="Grad">Gradientof F, if requested. Should not be computed if not requested</param>
            <param name="Hess">Hessian of F, if requested. Should not be computed if not requested</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting">
            <summary>Curve fitting applications</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.LeastSquares(System.Single[0:,0:],System.Single[],System.Single[],System.Single)">
            <summary>Computes least squares fitting of Ax = b weighted by W and returns x</summary>
            <param name="A">Dependent variables measurements</param>
            <param name="b">Independent variables measurements</param>
            <param name="W">Weights</param>
            <param name="lambda">Regularization term</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.LeastSquares(System.Single[0:,0:],System.Single[])">
            <summary>Computes least squares fitting of Ax = b and returns x</summary>
            <param name="A">Dependent variables measurements</param>
            <param name="b">Independent variables measurements</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.LeastSquares(System.Single[0:,0:],System.Single[],System.Single)">
            <summary>Computes least squares fitting of Ax = b and returns x</summary>
            <param name="A">Dependent variables measurements</param>
            <param name="b">Independent variables measurements</param>
            <param name="lambda">Regularization term</param>            
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMinimization(System.Single[],System.Single[0:,0:],System.Single[],System.Single[],System.Single[],System.Single,System.Single)">
            <summary>Computes the p-norm minimization of Ax - b with weights w, using q-norm regularization with weights lambda on x</summary>
            <param name="x0">Start point</param>
            <param name="A">Dependent variables</param>
            <param name="b">Independent variables measurements</param>
            <param name="W">Weights of each equation</param>
            <param name="lambda">Regularization term of each component of x</param>
            <param name="p">Ax - b minimization exponent</param>
            <param name="q">x regularization exponent</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMinimization(System.Single[],System.Single[0:,0:],System.Single[],System.Single[],System.Single[],System.Single,System.Single,System.Single[0:,0:],System.Single[])">
            <summary>Computes the p-norm minimization of Ax - b with weights w, using q-norm regularization with weights lambda on x</summary>
            <param name="x0">Start point</param>
            <param name="A">Dependent variables</param>
            <param name="b">Independent variables measurements</param>
            <param name="W">Weights of each equation</param>
            <param name="lambda">Regularization term of each component of x</param>
            <param name="p">Ax - b minimization exponent</param>
            <param name="q">x regularization exponent</param>
            <param name="AeqConstr">Equality constraint matrix AeqConstr * x = bConstr</param>
            <param name="bEqConstr">Equality constraint right hand side</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMinimization(System.Single[],OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Computes the p-norm minimization of Ax - b with weights w, using q-norm regularization with weights lambda on x</summary>
            <param name="x0">Start point</param>
            <param name="CLA">Dependent variables</param>
            <param name="CLb">Independent variables measurements</param>
            <param name="CLW">Weights of each equation</param>
            <param name="CLlambda">Regularization term of each component of x</param>
            <param name="CLp">Ax - b minimization exponent</param>
            <param name="CLq">x regularization exponent</param>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.kernelpNorm">
            <summary>Computes p-norm of a vector, sum(|xi|^p)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.kerneldpNorm">
            <summary>Computes gradients of p-norm</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMin">
            <summary>P-Norm minimization class</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMin.nUnknowns">
            <summary>Number of equations and of unknowns</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMin.nEqs">
            <summary>Number of equations and of unknowns</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMin.rnd">
            <summary>RNG</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMin.#ctor(System.Int32,System.Int32)">
            <summary>Constructor</summary>
            <param name="numUnknowns">Number of unknowns</param>
            <param name="numEquations">Number of equations</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMin.SetData(System.Single[],System.Single[0:,0:],System.Single[],System.Single[],System.Single[],System.Single,System.Single)">
            <summary>Sets data for problem solving</summary>
            <param name="x0">Start point</param>
            <param name="A">Dependent variables. Can be null if already set.</param>
            <param name="b">Independent variables measurements</param>
            <param name="W">Weights of each equation</param>
            <param name="lambda">Regularization term of each component of x</param>
            <param name="p">Ax - b minimization exponent</param>
            <param name="q">x regularization exponent</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMin.Solve">
            <summary>Solves current system</summary>
            <returns></returns>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.CurveFitting.PNormMinClass.F(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Boolean,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@)">
            <summary>Computes objective function, gradient and Hessian for p-norm minimization with q-norm regularization</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming">
            <summary>Quadratic problem solving</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.CheckFeasibility(System.Single[],System.Single[0:,0:],System.Single[],System.Single[0:,0:],System.Single[])">
            <summary>Checks if it's possible to satisfy Mx less than d and Ax = b. Returns a feasible point if so</summary>
            <param name="x0">Initial guess</param>
            <param name="M">Inequality constraint matrix</param>
            <param name="d">Inequality rhs</param>
            <param name="A">Equality constr matrix</param>
            <param name="b">Equality rhs</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.CheckFeasibility(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector)">
            <summary>Checks if it's possible to satisfy Mx less than d and Ax = b. Returns a feasible point in x0 if so</summary>
            <param name="x0">Initial guess</param>
            <param name="M">Inequality constraint matrix</param>
            <param name="d">Inequality rhs</param>
            <param name="A">Equality constr matrix</param>
            <param name="b">Equality rhs</param>
            <param name="Mxd">Temporary vector to hold M*x - d</param>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.kernelgetLast">
            <summary>Kernel to compute last element of a vector</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.Hpd">
            <summary>Primal dual Hessian n x n</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.rPri">
            <summary>Primal residual, c x 1</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.rCent">
            <summary>Centralization residual, m x 1</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.rDual">
            <summary>Dual residual, n x 1</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.ReadAll">
            <summary>DEBUG. Reads all vars from device</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolvePrimalDual(System.Single[],System.Single[],System.Single[],OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,System.Single[],System.Single[0:,0:],System.Single[],System.Single[0:,0:],System.Single[],OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.StopFunc)">
            <summary>Solves a quadratic programming problem 1/2 x'Px + q'x subject to Mx less or equal d and Ax = b</summary>
            <param name="x0">Start point x0</param>
            <param name="lambda0">Start dual point lambda0</param>
            <param name="nu0">Start nus (equality constraints)</param>
            <param name="P">Positive semidefinite quadratic objective matrix P</param>
            <param name="q">Linear objective q</param>
            <param name="M">Ineq constraint matrix M</param>
            <param name="d">Ineq constraint right hand side d</param>
            <param name="A">Constraint matrix A</param>
            <param name="b">Constraint right hand side b</param>
            <param name="sf">Stop function. The system won't check feasibility if this function is not null. Return true when you want the optimization to stop based on x, lambda and nu</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.ComputePrimalDualSearchDir(System.Single)">
            <summary>Computes primal dual search direction</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.PDResidual(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Single)">
            <summary>Computes the norm of the residuals in a given point</summary>
            <param name="x">Primal vars</param>
            <param name="lambda">Dual vars</param>
            <param name="nu">Equality constraint vars</param>
            <param name="t">Solution quuality parameter t</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolveBarrier(System.Single[],OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix,System.Single[],System.Single[0:,0:],System.Single[],System.Single[0:,0:],System.Single[],OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.StopFunc)">
            <summary>Solves a quadratic programming problem 1/2 x'Px + q'x subject to Mx less or equal d and Ax = b</summary>
            <param name="x0">Start point x0</param>
            <param name="P">Positive semidefinite quadratic objective matrix P</param>
            <param name="q">Linear objective q</param>
            <param name="M">Ineq constraint matrix M</param>
            <param name="d">Ineq constraint right hand side d</param>
            <param name="A">Constraint matrix A</param>
            <param name="b">Constraint right hand side b</param>
            <param name="sf">Stop function. The system won't check feasibility if this function is not null. Return true when you want the optimization to stop based on x, lambda and nu</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog">
            <summary>Log of various parameters of solution</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.KeepLog">
            <summary>Keep log of operations?</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.LogResiduals">
            <summary>Internal variable to keep track if needs to log residuals</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.Iterations">
            <summary>How many Newton directions were computed?</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.SurrDualityGaps">
            <summary>How did the duality gaps evolve?</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.EvolutionOfT">
            <summary>Evolution of last variable in the computation of feasibility. Problem becomes feasible when the var is less than zero</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.PtSequence">
            <summary>Sequence of points in problem solution</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.StepSizes">
            <summary>Primal dual step sizes</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.DualResiduals">
            <summary>Evolution of dual residuals</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.CentResiduals">
            <summary>Evolution of centralization residuals</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.SolutionLog.Clear">
            <summary>Clears log</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.StopFunc">
            <summary>Delegate to stop execution if that's thhe case (as in the feasibility problem, when we can quit if t less than zero)</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.ComputeRestrictions">
            <summary>Computes values of the restrictions</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.QuadraticProgramming.ComputePDResidualNorm">
            <summary>Computes norm of primal dual residuals vector</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression">
            <summary>Creates a one-vs-all classification system using Logistic Regression</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.kernelComputeLogistRegParams">
            <summary>Kernel to compute Logistic Regression cost function and gradient/Hessian parameters</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.kernelpNorm">
            <summary>Computes p-norm of a vector, sum(|xi|^p)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.kerneldpNorm">
            <summary>Computes gradients of p-norm</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.Categories">
            <summary>Total of categories</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.CLX">
            <summary>Samples matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.y">
            <summary>Classifications vector to use in training</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.lambda">
            <summary>Regularization parameter</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression._classifs">
            <summary>Classifications of each example</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.CLM">
            <summary>Matrix containing classification coefficients [numCategories, Sample dimension + 1] (because of interceptor)</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.#ctor(System.Single[0:,0:],System.Single[])">
            <summary>Constructor. Receives samples and trains classifier. Includes the intercept term automatically. Classifications that are equal to or
            less than zero are negative examples. Any non-zero classification will get its own logistic regression classifier</summary>
            <param name="Samples">Matrix containing one sample per line and n samples, [n, p]</param>
            <param name="Classifications">Vector of classifications, [n]</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.#ctor(System.Single[0:,0:],System.Single[],System.Single[],System.Single)">
            <summary>Constructor. Receives samples and trains classifier. Includes the intercept term automatically. Classifications that are equal to or
            less than zero are negative examples. Any non-zero classification will get its own logistic regression classifier</summary>
            <param name="Samples">Matrix containing one sample per line and n samples, [n, p]</param>
            <param name="Classifications">Vector of classifications, [n]</param>
            <param name="RegularizationWeights">Regularization weights, [p]</param>
            <param name="regularizationQ">Exponent of regularization term, sum (|beta|^q). Should be greater than 1</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.#ctor(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,System.Collections.Generic.List{System.Single})">
            <summary>Creates a new logistic regression classifier from already trained coefficients. 
            Note: GetInternalHitRate will not work! (because there are no internal samples)</summary>
            <param name="CLM">Coefficients, including interceptor coefficient</param>
            <param name="Categories">Classification categories</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.Train">
            <summary>Trains this classifier using the samples Matrix and classifications vector</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.RegularizedLogistReg(OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector,System.Boolean,OpenCLTemplate.LinearAlgebra.floatLinalg.floatVector@,OpenCLTemplate.LinearAlgebra.floatLinalg.floatSymPosDefMatrix@)">
            <summary>Computes cost function for logistic regression at a given x</summary>
            <param name="CLTheta">Current function point</param>
            <param name="ComputeGradHess">Compute gradient and hessian?</param>
            <param name="Grad">Gradientof F, if requested. Should not be computed if not requested</param>
            <param name="Hess">Hessian of F, if requested. Should not be computed if not requested</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.Classify(System.Single[],System.Single[]@)">
            <summary>Classifies a sample and returns classification values (the bigger, the most certain)
            Note: in the classical approach one would need to compute the 1/(1+exp(-Values[i])) to get the logistic rating</summary>
            <param name="Sample">Sample to be classified</param>
            <param name="Values">Classification values</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.Classify(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix@,System.Single[]@)">
            <summary>Classifies a Samples matrix, one sample per row. Note: the interceptor x[0] = 1 has to be included</summary>
            <param name="Samples">Samples matrix, [n x p+1], where p = original x dimension</param>
            <param name="Values">Classification values</param>
            <param name="maxVals">Maximum classification values. 
            Note: in the classical approach one would need to compute the 1/(1+exp(-Values[i])) to get the logistic rating</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.GetHitRate(OpenCLTemplate.LinearAlgebra.floatLinalg.floatMatrix,System.Single[])">
            <summary>Gets hit rate of a given set</summary>
            <param name="Samples">Samples to rate. One sample per row</param>
            <param name="Labels">Correct labels</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.GetHitRate(System.Single[0:,0:],System.Single[])">
            <summary>Gets hit rate of a given set</summary>
            <param name="Samples">Samples to rate. One sample per row</param>
            <param name="Labels">Correct labels</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.floatOptimization.LogisticRegression.GetInternalHitRate">
            <summary>Retrieves hit rate in training set</summary>
        </member>
        <member name="T:OpenCLTemplate.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:OpenCLTemplate.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:OpenCLTemplate.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:OpenCLTemplate.OMR.PolygonFinder">
            <summary>Polygon finder class</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.PolygonFinder.convex_hull(System.Collections.Generic.List{System.Drawing.PointF})">
            <summary>Returns a set which is the convex hull of a List of points</summary>
            <param name="P">List of points to compute convex hull</param>
        </member>
        <member name="M:OpenCLTemplate.OMR.PolygonFinder.ApproximatePolygon(System.Collections.Generic.List{System.Drawing.PointF},System.Int32)">
            <summary>Approximates a list of points using a limited amount of vertexes. This algorithm uses convex_hull subroutine</summary>
            <param name="PP">Set of points to approximate using nVertexes.</param>
            <param name="nVertexes">Number of vertexes to use</param>
            <returns></returns>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.XMLFuncs">
            <summary>Useful XML Functions</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.CreateNewTable(System.String,System.String[])">
            <summary>Creates new table</summary>
            <param name="TableName">Name</param>
            <param name="Fields">Table fields. String. Start with dbl to make doubles.</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.CreateColumn(System.Data.DataTable,System.Windows.Forms.Control)">
            <summary>Creates a column in a datatable if it does not exist and binds it to the control. 
            Added controls: Control name starts with txtInt: integer. Control name starts with "txt" - TextBox bound to Double. If textbox ends with "Name" - string.
            Control name starts with "radio" - Radio button. Boolean.
            Control name starts with "chk" - Check box. Boolean.
            Control name starts with "cmb" - Combo box. String.</summary>
            <param name="t">Datatable to analyze.</param>
            <param name="c">Control to create column from.</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.MakeTableFromDataGrid(System.Windows.Forms.DataGridView,System.String,System.Data.DataSet)">
            <summary>Creates a table containing a grid's structure. Sets data type based on column name: if it starts with: int -> Integer data type;
            string -> String data type; else -> Double.</summary>
            <param name="grid">DataGridView to read info from.</param>
            <param name="TableName">Name of table being created.</param>
            <param name="data">DataSet to store table.</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.CreateForm(System.Windows.Forms.BindingSource,System.Windows.Forms.Control,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Collections.Generic.List{System.String}})">
            <summary>Creates a form containing editable data</summary>
            <param name="BindSrc">Binding source to use</param>
            <param name="ParentControl">Control where to add items. A new panel is created there.</param>
            <param name="MultiLineCols">Columns containig multiline data</param>
            <param name="MultiFieldCols">Columns containing multiple data such as more than 1 objective, etc.</param>
            <param name="ComboboxCols">Columns which should be combo boxes</param>
            <param name="ComboboxItems">Data to populate each combobox</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.GenReport(System.Collections.Generic.List{OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow})">
            <summary>Generates report data</summary>
            <param name="Rows">Information to be included in the report</param>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.XMLFuncs.FileReader">
            <summary>Class to read text files.</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.FileReader.ReadFile(System.String)">
            <summary>Reads a text file and stores its lines in string arrays.</summary>
            <param name="FileName">File to read</param>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField">
            <summary>Creates a multiple container for varible sizes fields.
            Example: multiple objectives stored in a single field.</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.txtBinded">
            <summary>Text box bound to data source</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.lstItems">
            <summary>List box that will contain the items</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.btnAdd">
            <summary>Button to add a new item</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.btnRemove">
            <summary>Button to remove an item</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.txtEditItem">
            <summary>Text box to edit items</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.IsEditing">
            <summary>Is this class editing the bound textbox?</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Fields">
            <summary>Fields to be added</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.#ctor(System.Windows.Forms.TextBox,System.Windows.Forms.Control)">
            <summary>Constructor.</summary>
            <param name="BindedTextBox">TextBox bound to the data source</param>
            <param name="ParentControl">Control to use to add the necessary items</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.GetNextTop">
            <summary>Gets next Top position to place controls.</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.UpdateListBox">
            <summary>Uses Fields to update listbox</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config">
            <summary>MultiField configuration</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config.VerticalSpacing">
            <summary>Vertical spacing</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config.HorizSpacing">
            <summary>Horizontal spacing</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config.AddButtonTitle">
            <summary>"Add button" title</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config.RemButtonTitle">
            <summary>"Remove button" title</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config.ItemsListBoxHeight">
            <summary>Items list box height</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config.BtnsWidth">
            <summary>Buttons width</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.MultiField.Config.TxtEditHeight">
            <summary>Editable textbox height</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow">
            <summary>DataRow information to include in a report</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow.Table">
            <summary>Table of the item to generate in report</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow.Row">
            <summary>Row containing report data</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow.DesiredColumns">
            <summary>Information that should be put in the data</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow.#ctor(System.Data.DataTable,System.Data.DataRow,System.Collections.Generic.List{System.String})">
            <summary>Creates a new report row</summary>
            <param name="t">Datatable</param>
            <param name="r">Datarow</param>
            <param name="DesiredInfo">Columns to include</param>
        </member>
        <member name="P:OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow.ItemTable">
            <summary>Gets table of the item to generate in report</summary>
        </member>
        <member name="P:OpenCLTemplate.MachineLearning.XMLFuncs.ReportRow.ItemRow">
            <summary>
            Row
            </summary>
        </member>
        <member name="T:LinearAlgebra.Matrix">
            <summary>Creates a Matrix of real numbers.</summary>
        </member>
        <member name="F:LinearAlgebra.Matrix.Items">
            <summary>Matrix items</summary>
        </member>
        <member name="F:LinearAlgebra.Matrix.LINALGMAXERROR">
            <summary> Linear Solve parameter. Maximum mean error allowable to linear solve method.</summary>
        </member>
        <member name="F:LinearAlgebra.Matrix.LIMITITERS">
            <summary> Linear Solve parameter. Limit linear solution correction iterations.</summary>
        </member>
        <member name="F:LinearAlgebra.Matrix.IGNOREHARDSINGULARITY">
            <summary> Linear Solve parameter. Should the solution method halt if a hard singulariry is found in matrix?</summary>
        </member>
        <member name="F:LinearAlgebra.Matrix.IGNORENULLDETERMINANT">
            <summary> Linear Solve parameter. Should the method ignore if the matrix has a close-to-zero determinant and keep solving?</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.#ctor">
            <summary> Constructor. Initializes a [0,0] matrix.</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.#ctor(System.Double[0:,0:])">
            <summary> Constructor. Creates matrix from existing items.</summary>
            <param name="MatrixItems">Matrix items to create matrix from.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.#ctor(LinearAlgebra.Matrix)">
            <summary> Copy constructor.</summary>
            <param name="m">Matrix to copy from.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.#ctor(System.Int32,System.Int32)">
            <summary> Constructor. Creates empty matrix with specified dimensions.</summary>
            <param name="numRows">Number of rows in matrix.</param>
            <param name="numCols">Number of columns in matrix.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Addition(LinearAlgebra.Matrix,LinearAlgebra.Matrix)">
            <summary> Sums two matrixes.</summary>
            <param name="m1">First matrix to sum.</param>
            <param name="m2">Second matrix to sum.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Subtraction(LinearAlgebra.Matrix,LinearAlgebra.Matrix)">
            <summary> Subtracts two matrixes.</summary>
            <param name="m1">Matrix to subtract from.</param>
            <param name="m2">Matrix to be subtracted.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Multiply(LinearAlgebra.Matrix,LinearAlgebra.Matrix)">
            <summary> Matrix multiplication. Notice that m1 rows should be the same as m2 lines for compatibility.</summary>
            <param name="m1">First matrix to multiply.</param>
            <param name="m2">Second matrix to multiply.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Multiply(System.Double,LinearAlgebra.Matrix)">
            <summary> Matrix scalar multiplication.</summary>
            <param name="m">Matrix to multiply.</param>
            <param name="num">Scalar to multiply.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Multiply(LinearAlgebra.Matrix,System.Double)">
            <summary> Matrix scalar multiplication.</summary>
            <param name="m">Matrix to multiply.</param>
            <param name="num">Scalar to multiply.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Multiply(LinearAlgebra.Matrix,System.Double[])">
            <summary> Matrix post-vector multiplication. Notice that a vector is a [1,Cols] matrix which means
            vector length should be equal matrix number of columns.</summary>
            <param name="m">Matrix to multiply.</param>
            <param name="vet">vector to multiply.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Multiply(System.Double[],LinearAlgebra.Matrix)">
            <summary> Matrix pre-vector multiplication. Notice that a vector is a [1,Cols] matrix which means
            vector length should be equal matrix number of lines.</summary>
            <param name="m">Matrix to multiply.</param>
            <param name="vet">vector to multiply.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.op_Division(LinearAlgebra.Matrix,System.Double)">
            <summary> Matrix scalar division.</summary>
            <param name="m">Matrix to multiply.</param>
            <param name="num">Scalar to divide each element of matrix.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.Equals(LinearAlgebra.Matrix)">
            <summary>Compares matrixes and returns true if they are identical.</summary>
            <param name="Matrix">Matrix to compare to.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.Transpose">
            <summary>Returns matrix transpose.</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.MultiplyElementWise(LinearAlgebra.Matrix)">
            <summary>Element-wise product. This is not regular matrix product. It multiplies elements 
            at corresponding positions.</summary>
            <param name="Matrix">Matrix to multiply element-wise.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.NormEuclidean">
            <summary>Returns Euclidean norm of the matrix.</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.Dot(LinearAlgebra.Matrix)">
            <summary>Dot product of two matrixes.</summary>
            <param name="Matrix">Matrix to dot product with/</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.InvertElements">
            <summary>Element-wise inversion. Returns the matrix with each element (x) inverted (1/x).</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.LUDecomp">
            <summary>Creates internal LU factorization of this matrix.</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.LinearSolve(System.Double[])">
            <summary>Returns the solution x to the linear system Ax=b, A being this matrix.</summary>
            <param name="b">Right-hand side known values.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.Determinant">
            <summary>Returns the determinant of this matrix.</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.Inversa">
            <summary>Returns the inverse of this matrix.</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.IdentifyParameters(System.Double[])">
            <summary>Returns the solution x to the linear system A'Ax=A'b, A being this matrix.</summary>
            <param name="Y">Right-hand side known values.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.IdentifyParametersWeighted(System.Double[],LinearAlgebra.Matrix)">
            <summary>Returns the weighted solution x to the linear system A'WAx=A'Wb, 
            A being this matrix. TO DO: Correct quality check</summary>
            <param name="Y">Right-hand side known values.</param>
            <param name="W">Weight matrix.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.IdentifyParametersWeighted(System.Double[],System.Double[])">
            <summary>Returns the weighted solution x to the linear system A'DAx=A'Db, 
            A being this matrix. D is a diagonal weight matrix.</summary>
            <param name="Y">Right-hand side known values.</param>
            <param name="w">Main diagonal elements of diagonal weight matrix D.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.CheckQuality(System.Double[],System.Double[])">
            <summary>Calculates R², corrected R² and Quadratic Error for the trySolution x to the linear system A'Ax=A'b, 
            A being this matrix.</summary>
            <param name="Y">Right-hand side known values.</param>
            <param name="trySolution">Solution to use to evaluate quality indexers.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.GramSchmidt">
            <summary>Applies the Gram-Schmidt orthonormalization method to this matrix, replacing 
            it by the orthonormalized matrix.</summary>
        </member>
        <member name="M:LinearAlgebra.Matrix.GramSchmidt(System.Double[]@)">
            <summary>Applies the Gram-Schmidt orthonormalization method to this matrix, replacing 
            it by the orthonormalized matrix and also correcting right-hand Y values for a linear system solve.</summary>
            <param name="y">Right-hand side known values.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.GramSchmidt(System.Int32[],System.Int32,System.Double[]@)">
            <summary>Applies the Gram-Schmidt orthonormalization method to this matrix using 
            a pre-set order of normalization. Replaces current matrix
            by the orthonormalized matrix and also correcting 
            right-hand Y values for a linear system solve.</summary>
            <param name="y">Right-hand side known values.</param>
            <param name="lineOrder">Line order to apply the orthonormalization method.</param>
            <param name="indStart">Starts orthonormalization from line lineOrder[indStart]. Assumes previous lines are already
            normalized.</param>
        </member>
        <member name="M:LinearAlgebra.Matrix.ToString">
            <summary>Returns a string representing this matrix.</summary>
        </member>
        <member name="P:LinearAlgebra.Matrix.Item(System.Int32,System.Int32)">
            <summary> Accesses items in current matrix.</summary>
            <param name="i">Row of element to access.</param>
            <param name="j">Column of element to access.</param>
        </member>
        <member name="P:LinearAlgebra.Matrix.rowCount">
            <summary> Gets the number of rows in this matrix.</summary>
        </member>
        <member name="P:LinearAlgebra.Matrix.colCount">
            <summary> Gets the number of columns in this matrix.</summary>
        </member>
        <member name="P:LinearAlgebra.Matrix.RSquareIndex">
            <summary>Returns the R² index of last fit.</summary>
        </member>
        <member name="P:LinearAlgebra.Matrix.RSquareCorrectedIndex">
            <summary>Returns corrected R² index of last fit.</summary>
        </member>
        <member name="P:LinearAlgebra.Matrix.QuadraticError">
            <summary>Returns the sum of quadratic errors of last fit.</summary>
        </member>
        <member name="T:OpenCLTemplate.frmCLInfo">
            <summary>Displays OpenCL related information</summary>
        </member>
        <member name="M:OpenCLTemplate.frmCLInfo.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="F:OpenCLTemplate.frmCLInfo.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:OpenCLTemplate.frmCLInfo.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:OpenCLTemplate.frmCLInfo.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.SparseLinalg">
            <summary>OpenCL linear algebra functions</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.IMGWIDTH">
            <summary>Width to be used in float4's</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.GLOBALWORKSIZE">
            <summary>Total number of workers</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.#cctor">
            <summary>Static Constructor. Builds kernels</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.vLenBy4">
            <summary>Vector length divided by 4 (plus 1)</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.dotProd">
            <summary>OpenCL memory Dot product</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.dprod">
            <summary>Dot product, host memory</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.dotProdSum">
            <summary>OpenCL memory Dot product final summation</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.kernelDotProduct">
            <summary>OpenCL dot product Kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.kernelSum">
            <summary>OpenCL dot product sum elements kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.kernelGetDotSum">
            <summary>OpenCL get final answer</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.DotProduct(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector)">
            <summary>Computes dot product of 2 vectors using their OpenCL images. Assumes data has been inserted to VectorData and WriteToDevice() has been called</summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLDotProd(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector)">
            <summary>Computes dot product of two vectors and stores result in
            dotProdSum</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.DotProductNoCL(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector)">
            <summary>Computes dot product of 2 vectors without OpenCL</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.ExactDotProductNoCL(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector)">
            <summary>Computes dot product of 2 vectors without OpenCL, in double precision</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.kernelSparseMatrixVecMult">
            <summary>OpenCL sparse matrix vector product</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLNonZeroElemsPerRow">
            <summary>Non-zero elements per row</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.Multiply(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector)">
            <summary>Computes M*x and stores the result in y. Does not automatically read result from device memory</summary>
            <param name="M">Sparse matrix</param>
            <param name="x">Vector to be multiplied</param>
            <param name="y">Result</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.ExactMultiply(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector)">
            <summary>Computes exact double-precision product of sparse matrix M and vector x</summary>
            <param name="M">Sparse matrix</param>
            <param name="x">Vector to be multiplied</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.MultiplyNoCL(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector)">
            <summary>Computes product of sparse matrix M and vector x</summary>
            <param name="M">Sparse matrix</param>
            <param name="x">Vector to be multiplied</param>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.r">
            <summary>Residues</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.p">
            <summary>Gradient direction</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.x">
            <summary>Initial guess/answer holder</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.Ap">
            <summary>A times p vector</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.temp">
            <summary>Temporary storage vector</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.lambda">
            <summary>Value to store some vector</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLlambda">
            <summary>Value to use to multiply some vector</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.kernelInitRP">
            <summary>Initialize r and p values</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.kernelMultiplyAdd">
            <summary>Mad kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.kernelCopyToTemp">
            <summary>Copy to temporary image kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.MAXITER">
            <summary>Maximum number of iterations</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.LinSolveNoCL(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,System.Single)">
            <summary>Solves linear system Mx = b using conjugate gradient method</summary>
            <param name="M">Matrix M</param>
            <param name="b">Vector b</param>
            <param name="tol">Error tolerance</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.LinSolveCL(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,System.Single)">
            <summary>Solves linear system Mx = b using conjugate gradient method. Writes variables to Device memory. Improves solution if accuracy is low.</summary>
            <param name="M">Matrix M</param>
            <param name="b">Vector b</param>
            <param name="tol">Error tolerance</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.LinSolveCLStep(OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector,System.Single,OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector@)">
            <summary>Solves linear system Mx = b using conjugate gradient method. Doesn't try to improve the solution obtained.</summary>
            <param name="M">Matrix M</param>
            <param name="b">Vector b</param>
            <param name="tol">Error tolerance</param>
            <param name="x">Initial guess</param>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector">
            <summary>Builds a new OpenCL Image2D containing vector data</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.n">
            <summary>Vector length. Allocated length is multiple of 4096 = 2^12</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.nRows">
            <summary>Number of rows to accomodate the size. Number of columns is 4096 float4's, so up to 4096*4 it will be
            only 1 row.</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.CLVector">
            <summary>Image2D representing vector contents</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.VectorData">
            <summary>Vector to be written/read from Device memory. Call WriteToDevice to effectively copy to Device memory</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.#ctor(System.Int32)">
            <summary>Creates a new vector allocated in OpenCL Image2D object.</summary>
            <param name="Length">Vector length. For convenience some extra memory is allocated but calculations only go up to vector dimensions</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.WriteToDevice">
            <summary>Effectively writes contents of VectorData to Device memory</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.ReadFromDevice">
            <summary>Reads contents of CLVector image2d to VectorData</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgVector.Length">
            <summary>Gets the length of this vector</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix">
            <summary>Builds a new OpenCL Image2D containig a sparse matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.MatrixData">
            <summary>Matrix data arranged in format numRows*nonZeroElemsPerRow.</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.Columns">
            <summary>True column of element</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.CLMatrixData">
            <summary>Image2D representing vector contents</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.CLColumns">
            <summary>Image2D containing column indexes</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.nElems">
            <summary>Total number of elements, N*nonZeroElemsPerRow</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.numRows">
            <summary>Number of rows of matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.elemsPerRow">
            <summary>Number of elements stored per row</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.SetValue(System.Single,System.Int32,System.Int32)">
            <summary>Stores a matrix value at a particular row and column</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.GetValue(System.Int32,System.Int32)">
            <summary>Gets the value of a matrix element</summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.WriteToDevice">
            <summary>Effectively writes contents of Matrix to Device memory</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.ReadFromDevice">
            <summary>Reads contents of CLMatrix image2d to Matrix Host memory</summary>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.#ctor(System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="N">NxN dimension of the matrix</param>
            <param name="nonZeroElemsPerRow">Maximum number of non-zero elements per row</param>
        </member>
        <member name="M:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.ToString">
            <summary>String representation of complete matrix. Returns at most 10000 elements</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.NonZeroElemsPerRow">
            <summary>Gets number of elements stored per row</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.MatrixDimension">
            <summary>Gets matrix dimension (M[NxN])</summary>
        </member>
        <member name="P:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLImgSparseMatrix.Item(System.Int32,System.Int32)">
            <summary>Gets or sets value for matrix elements</summary>
        </member>
        <member name="T:OpenCLTemplate.LinearAlgebra.SparseLinalg.CLLinalgSrc">
            <summary>OpenCL dot product source</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender">
            <summary>OpenGL render control</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.ParentForm">
            <summary>Parent form</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLCtrl">
            <summary>OpenGL control</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.CreateCLGLContext(System.Int32)">
            <summary>Sets CL GL shared variables</summary>
            <param name="DeviceNumber">Index of device to use from ComputePlatform.Platforms[0].Devices. Use -1 for default</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.#ctor(System.Windows.Forms.Form,System.Boolean,System.Int32)">
            <summary>Constructor. Adds a OpenGL Control to desired form</summary>
            <param name="ParentForm">OpenGL control parent form</param>
            <param name="CreateCLGLCtx">Create OpenGL/OpenCL shared context?</param>
            <param name="DeviceNumber">Index of device to use from ComputePlatform.Platforms[0].Devices. Use -1 for default</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.InitGL(System.Boolean,System.Int32)">
            <summary>Typical OpenGL initialization</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.MouseMode">
            <summary>Mouse rotation mode</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.RecalcZnearZFar">
            <summary>Automatically recalculates zNear and zFar values</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.center">
            <summary>Point where camera is looking at</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.eye">
            <summary>Point where camera is standing</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.front">
            <summary>Front vector</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.up">
            <summary>Up vector</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.esq">
            <summary>Left vector</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.distEye">
            <summary>Camera eye distance.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.zFar">
            <summary>Far distance to clip at.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.zNear">
            <summary>Near distance to clip at</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.RepositionCamera(System.Single,System.Single,OpenCLTemplate.CLGLInterop.GLRender.MouseMoveMode)">
            <summary>Repositions camera.</summary>
            <param name="mouseDX">X mouse displacement.</param>
            <param name="mouseDY">Y mouse displacement.</param>
            <param name="modo">Mouse displacement mode (user wants translation or rotation?)</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.Fly(OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Function to advance view and allow "fly" simulations.</summary>
            <param name="Distance">Distance to fly</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.ConsolidateRepositioning">
            <summary>Updates temporary displacement vectors to internal drawing vectors.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.RepositionLight">
            <summary>Repositions light.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.Mouse3D">
            <summary>Mouse 3D model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.lblMouseToCenterDist">
            <summary>Show mouse to center distance in this label if not null</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.Create3DMouseModel(System.Single[])">
            <summary>Creates a 3D Model for the mouse</summary>
            <param name="Color">Desired color</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.Reset3DMousePos">
            <summary>Resets 3D mouse position to center of view</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.Translate3DMouseXY(System.Single,System.Single,System.Single)">
            <summary>Translates 3D mouse to a given Left - Top</summary>
            <param name="x">Left relative value, 0 to 1</param>
            <param name="y">Up relative value, 0 to 1</param>
            <param name="dz">Z (depth) relative value</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.Increment3DMousePos(System.Single,System.Single,System.Single)">
            <summary>Increments current mouse position</summary>
            <param name="dx">Left relative value</param>
            <param name="dy">Up relative value</param>
            <param name="dz">Z (depth) relative value</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.Process3DMouseHit(System.Windows.Forms.MouseEventArgs)">
            <summary>Processes 3D mouse event</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.CLGLCtx">
            <summary>OpenGL/CL shared context</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.CQ">
            <summary>OpenGL/CL shared command queue</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.CLMousePos">
            <summary>Mouse position in GPU memory</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.MousePosAnt">
            <summary>Previous mouse position (when clicked)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.CLMousePosAnt">
            <summary>Previous mouse position in GPU memory</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.CLMouseRadius">
            <summary>Mouse radius in GPU memory</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.kernelHide">
            <summary>Hide/show kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.kernelShowAll">
            <summary>Hide/show kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.kernelHideLines">
            <summary>Hide/show kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.kernelDisplace">
            <summary>Displacement kernel</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.InitCLDisp">
            <summary>Initializes OpenCL kernels to calculate displacement and hide objects</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.CQWrite(Cloo.ComputeBuffer{System.Single},System.Single[])">
            <summary>Writes information to a buffer</summary>
            <param name="buffer">Buffer object</param>
            <param name="Values">Values to write</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.ShowAllElements">
            <summary>Undoes all hide operations and shows all elements</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.HideElements">
            <summary>Hides elements in this GLRender which are close to the 3D mouse</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.DisplaceElements">
            <summary>Displace elements according to mouse command</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.Models">
            <summary>List of OpenGL VBOs to draw</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.StereoscopicDraw">
            <summary>Draw in stereographic projection?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.StereoDistance">
            <summary>Stereographic distance.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.ClearColor">
            <summary>Background color</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.ReDraw">
            <summary>Forces the control to redraw its contents</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.PreDrawFunc">
            <summary>Function to be invoked prior to every drawing</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.Draw">
            <summary>Controls the camera positioning for the OpenGL scene</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.DrawAxes">
            <summary>Draw axes at center?</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.DoDraw">
            <summary>Draws OpenGL scene</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.SetCenter(OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Sets center of camera and recalculates appropriate vectors</summary>
            <param name="NewCenter">Desired center</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.SetDistance(System.Double)">
            <summary>Sets the camera distance from the center of where it's looking</summary>
            <param name="Distance">New distance</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GetCenter">
            <summary>Gets camera center (the center of where the camera is looking at)</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GetDistance">
            <summary>Gets camera distance from the center</summary>
        </member>
        <member name="E:OpenCLTemplate.CLGLInterop.GLRender.Mouse3DDown">
            <summary>Raised when user clicks mouse button in environment using Mouse3D mode</summary>
        </member>
        <member name="E:OpenCLTemplate.CLGLInterop.GLRender.Mouse3DUp">
            <summary>Raised when user releases mouse button in environment using Mouse3D mode</summary>
        </member>
        <member name="E:OpenCLTemplate.CLGLInterop.GLRender.Mouse3DMove">
            <summary>Raised when user moves 3D mouse in environment using Mouse3D mode</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.Mouse3DEvent">
            <summary>Mouse 3D event</summary>
            <param name="sender">Sender</param>
            <param name="e">2D events raised in this instance (picture X, Y and buttons)</param>
            <param name="Mouse3DPos">Mouse 3D position</param>
            <param name="Mouse3DRadius">Mouse 3D radius</param>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.MouseMoveMode">
            <summary>Mouse action when used to move the 3D Model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.MouseMoveMode.RotateModel">
            <summary>Mouse rotation mode index.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.MouseMoveMode.TranslateModel">
            <summary>Mouse translation mode index.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.MouseMoveMode.Mouse3D">
            <summary>Enter 3D mousing mode</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.MouseMoveMode.None">
            <summary>No mouse movement.</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.VoidFunc">
            <summary>Void function delegate</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel">
            <summary>OpenGL Model created from vertex buffer objects</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Name">
            <summary>Model name</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.UseDrawElements">
            <summary>Use draw elements? Just for compatibility with Lab3D models</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.#ctor(OpenTK.Graphics.OpenGL.BeginMode)">
            <summary>Constructor. Receives draw mode of the model. REMINDER: Vertex, color and element data are necessary for drawing.</summary>
            <param name="DrawMode">OpenGL Draw model</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.#ctor(OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel)">
            <summary>Constructor. Reuses the same Vertex Buffer Elements of an existing 3D model.</summary>
            <param name="Source">Source model to reuse buffer elements</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.LoadFile(System.String)">
            <summary>Creates 3D model from a given file</summary>
            <param name="FileName">Source file</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Dispose">
            <summary>Disposes buffer objects</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.DrawMode">
            <summary>VBO draw mode</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GLVertexBuffer">
            <summary>GL Vertex VBO (xyz)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GLColorBuffer">
            <summary>GL Color VBO (RGBA)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GLNormalBuffer">
            <summary>GL Normals VBO (xyz)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GLTexCoordBuffer">
            <summary>GL Tex Coords VBO (xy)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GLElemBuffer">
            <summary>GL Element buffer VBO (v1 v2 v3)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GLTextureBuffer">
            <summary>OpenGL texture buffer object</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.ElemLength">
            <summary>Length of elements vector (total triangles = ElemLength/3)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.numVertexes">
            <summary>How many vertexes are there?</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetVertexData(System.Single[])">
            <summary>Sets vertex data information</summary>
            <param name="VertexData">Vertex data information. v[3i] = x component of i-th vector, x[3i+1] = y component, x[3i+2] = z component</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetVertexData(System.Single[],OpenTK.Graphics.OpenGL.BufferUsageHint)">
            <summary>Sets vertex data information</summary>
            <param name="VertexData">Vertex data information. v[3i] = x component of i-th vector, x[3i+1] = y component, x[3i+2] = z component</param>
            <param name="Hint">OpenGL buffer usage hint</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetNormalData(System.Single[])">
            <summary>Sets vertex normals data information</summary>
            <param name="NormalVertexData">Normals data information. v[3i] = x component of i-th vector normal, x[3i+1] = y component, x[3i+2] = z component</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetNormalData(System.Single[],OpenTK.Graphics.OpenGL.BufferUsageHint)">
            <summary>Sets vertex normals data information</summary>
            <param name="NormalVertexData">Normals data information. v[3i] = x component of i-th vector normal, x[3i+1] = y component, x[3i+2] = z component</param>
            <param name="Hint">OpenGL buffer usage hint</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetTexCoordData(System.Single[])">
            <summary>Sets texture coordinate data information</summary>
            <param name="TexData">Vertex data information. v[2i] = x texture coord, x[2i+1] = y texture coordinate</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetTexCoordData(System.Single[],OpenTK.Graphics.OpenGL.BufferUsageHint)">
            <summary>Sets texture coordinate data information</summary>
            <param name="TexData">Vertex data information. v[2i] = x texture coord, x[2i+1] = y texture coordinate</param>
            <param name="Hint">OpenGL buffer usage hint</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetColorData(System.Single[])">
            <summary>Sets color information</summary>
            <param name="ColorData">Vertex data information. v[4i] = R, x[4i+1] = G, x[4i+2]=B, x[4i+3]=alpha</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetColorData(System.Single[],OpenTK.Graphics.OpenGL.BufferUsageHint)">
            <summary>Sets color information</summary>
            <param name="ColorData">Vertex data information. v[4i] = R, x[4i+1] = G, x[4i+2]=B, x[4i+3]=alpha</param>
            <param name="Hint">OpenGL buffer usage hint</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetColorData(System.Single[],System.Int32,OpenTK.Graphics.OpenGL.BufferUsageHint)">
            <summary>Sets color information</summary>
            <param name="ColorData">Vertex data information. v[4i] = R, x[4i+1] = G, x[4i+2]=B, x[4i+3]=alpha</param>
            <param name="offSet">Offset in number of elements</param>
            <param name="Hint">OpenGL buffer usage hint</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetElemData(System.Int32[])">
            <summary>Sets vertex normals data information</summary>
            <param name="ElemData">Element data information. v[3i]  v[3i+1] and v[3i+2] are indexes of vertexes that will be drawn</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetElemData(System.Int32[],OpenTK.Graphics.OpenGL.BufferUsageHint)">
            <summary>Sets vertex normals data information</summary>
            <param name="ElemData">Element data information. v[3i]  v[3i+1] and v[3i+2] are indexes of vertexes that will be drawn</param>
            <param name="Hint">OpenGL buffer usage hint</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.SetTexture(System.Drawing.Bitmap)">
            <summary>Creates a texture from a bitmap and associates with this model. Note: texture is flipped in Y axis, needs to correct texture coordinates.
            Models created from equations are already corrected</summary>
            <param name="bmp">Bitmap to create texture from</param>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.rad2deg">
            <summary>Radian to degree conversion</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.ShowModel">
            <summary>Show this model?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.vetTransl">
            <summary>Object translation vector from origin.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.vetRot">
            <summary>Object rotation vector in Euler angles (psi-theta-phi).</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Scale">
            <summary>Model scaling {ScaleX, ScaleY, ScaleZ}</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.ModelColor">
            <summary>This can be used to set model color if color buffer is not being used. Order: RGBA</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.DrawModel">
            <summary>Draws this model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CLElemBuffer">
            <summary>Local storage of element data buffer</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GetCLElemBuffer">
            <summary>Retrieves an OpenCL float buffer from this object's OpenGL elements VBO (3 ints per element)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CLColorBuffer">
            <summary>Local storage of color buffer</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GetCLColorBuffer">
            <summary>Retrieves an OpenCL float buffer from this object's OpenGL color data VBO (4 floats per vertex)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CLTexCoordBuffer">
            <summary>Local storage of texture coordinates buffer</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GetCLTexCoordBuffer">
            <summary>Retrieves an OpenCL float buffer from this object's OpenGL texture coordinate data VBO (2 floats per vertex)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CLNormalBuffer">
            <summary>Local storage of vertex normals buffer</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GetCLNormalBuffer">
            <summary>Retrieves an OpenCL float buffer from this object's OpenGL vertex normals data VBO (3 floats per vertex)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CLVertexBuffer">
            <summary>Local storage of vertex buffer</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GetCLVertexBuffer">
            <summary>Retrieves an OpenCL float buffer from this object's OpenGL vertex data VBO (3 floats per vertex)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CLTexture2D">
            <summary>Local storage of vertex buffer</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.GetCLTexture2D">
            <summary>Retrieves an OpenCL float buffer from this object's OpenGL vertex data VBO (3 floats per vertex)
            IMPORTANT: The data type of this object from the HOST standpoint is BYTE in the Alpha Blue Green Red order.
            The data type in OpenCL C99 is FLOAT4 (write_imagef) and in OpenGL the display order is BLUE GREEN RED ALPHA when modifying from OpenCL</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CreateSurface(System.Single[],System.Single[],System.String[],System.String[],System.String[])">
            <summary>Creates a surface from given equations. Parameters are u and v (strings). Eg: vertexEqs[0] = "u+v"</summary>
            <param name="uParams">U coordinate parameters: [0] - uMin, [1] - uMax, [2] - number of points</param>
            <param name="vParams">V coordinate parameters: [0] - vMin, [1] - vMax, [2] - number of points</param>
            <param name="vertexEqs">Array containing 3 strings that will define vertex positions. [0] x(u,v), [1] y(u,v), [2] z(u,v)</param>
            <param name="colorEqs">Array containing 4 strings that will define vertex colors R(u,v), G(u,v), B(u,v), A(u,v). May contain only RGB</param>
            <param name="normalsEqs">Array containing strings that will define vertex normals</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.CreateSurface(System.Single[],System.Single[],System.String[],System.String[])">
            <summary>Creates a surface from given equations. Parameters are u and v (strings). Eg: vertexEqs[0] = "u+v"</summary>
            <param name="uParams">U coordinate parameters: [0] - uMin, [1] - uMax, [2] - number of points</param>
            <param name="vParams">V coordinate parameters: [0] - vMin, [1] - vMax, [2] - number of points</param>
            <param name="vertexEqs">Array containing 3 strings that will define vertex positions. [0] x(u,v), [1] y(u,v), [2] z(u,v)</param>
            <param name="normalsEqs">Array containing strings that will define vertex normals</param>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder">
            <summary>3D Models handler from Lab3D software. Used to create 3D models from .OBJ and .DXF</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.HardwareSupportsBufferObjects">
            <summary>Checks if hardware supports Buffer Objects</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Name">
            <summary>3D Model name.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder._partes">
            <summary>List of parts that construct this 3D Model.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder._vertices">
            <summary>List of this 3D Model's vertexes.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder._vetNormais">
            <summary>List of this 3D Model's normal vectors.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder._vetTextureCoords">
            <summary>List of this 3D Model's texture vectors coordinates.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.TextureBitmap">
            <summary>Texture bitmap to use</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.GLTexture">
            <summary>OpenGL texture of this model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CG">
            <summary>Vertexes average coordinate (center of gravity).</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Dimens">
            <summary>Size of rectangle that contains this 3D Model.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.minPoint">
            <summary>Minimum Z coordinate of this model. Useful for reading terrain.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.#ctor">
            <summary>Empty constructor.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.#ctor(System.String,OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CoordFuncXYZ,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Constructor. Creates a 3D Model from parameterized 3D equations</summary>
            <param name="Name">Model name.</param>
            <param name="F">Coordinate function F. Has to return double[3] {x, y, z} or double[6] {x,y,z,nx,ny,nz}, n? = normals</param>
            <param name="umin">Minimum value of u coordinate.</param>
            <param name="umax">Maximum value of u coordinate.</param>
            <param name="vmin">Minimum value of v coordinate.</param>
            <param name="vmax">Maximum value of v coordinate.</param>
            <param name="uPts">Number of points in u partition.</param>
            <param name="vPts">Number of points in v partition.</param>
            <param name="cor">Color vector. x=red, y=green, z=blue. Goes from 0 to 1.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.#ctor(System.String,OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CoordFuncXYZ,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,OpenCLTemplate.CLGLInterop.Vector,System.Drawing.Bitmap)">
            <summary>Constructor. Creates a 3D Model from parameterized 3D equations with texture.</summary>
            <param name="Name">Model name.</param>
            <param name="F">Coordinate function F. Has to return double[3] {x, y, z} or double[6] {x,y,z,nx,ny,nz}, n? = normals</param>
            <param name="umin">Minimum value of u coordinate.</param>
            <param name="umax">Maximum value of u coordinate.</param>
            <param name="vmin">Minimum value of v coordinate.</param>
            <param name="vmax">Maximum value of v coordinate.</param>
            <param name="uPts">Number of points in u partition.</param>
            <param name="vPts">Number of points in v partition.</param>
            <param name="cor">Color vector. x=red, y=green, z=blue. Goes from 0 to 1.</param>
            <param name="Texture">Texture bitmap.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.#ctor(System.String,OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CoordFuncXYZ,System.Single,System.Single,System.Int32,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Constructor. Creates a 3D Model from parameterized 3D line equations.</summary>
            <param name="Name">Model name.</param>
            <param name="F">Coordinate function F. Has to return double[3] {x, y, z} or double[6] {x,y,z,nx,ny,nz}, n? = normals.
            Notice only parameter u is passed (v=0)</param>
            <param name="umin">Minimum value of u coordinate.</param>
            <param name="umax">Maximum value of u coordinate.</param>
            <param name="uPts">Number of points in u partition.</param>
            <param name="cor">Color vector. x=red, y=green, z=blue. Goes from 0 to 1.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.trataLinha(System.String)">
            <summary>Removes spaces from line and understands , and . as decimal separators.</summary>
            <param name="linha">Line to be rewritten.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.#ctor(System.String)">
            <summary>Constructor. Creates 3D Model from file.</summary>
            <param name="file">File to read 3D data.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.lerOBJ(System.String)">
            <summary>Reads 3D model from Wavefront .OBJ</summary>
            <param name="fileOBJ">File to read</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.FinishReadFile">
            <summary>Does standard endfile operations (smooth normals, CG calculation)</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.lerDXF(System.String)">
            <summary>Reads 3D model from Autodesk DXF</summary>
            <param name="fileDXF">File to read</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.ler3DFace(System.IO.StreamReader)">
            <summary>Reads 3DFACE element</summary>
            <param name="sr">Stream</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.lerPolyline(System.IO.StreamReader)">
            <summary>Reads POLYLINE element</summary>
            <param name="sr">Stream</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.lerCoords(System.IO.StreamReader)">
            <summary>Reads 4 vertexes from a streamreader (10 20 30, 11 21 31, 12 22 32, 13 23 33)</summary>
            <param name="sr">Streamreader</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.lerCoord(System.IO.StreamReader)">
            <summary>Reads a single vertex (10 20 30)</summary>
            <param name="sr">Streamreader</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.GetTexture(System.String,System.String)">
            <summary>Attempts to load texture</summary>
            <param name="TexFile">Picture file containing texture</param>
            <param name="OBJFile">OBJ file to read path from.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Create3DModel(System.String,OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CoordFuncXYZ,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Recreates 3D Model from parameterized 3D equations</summary>
            <param name="Name">Model name.</param>
            <param name="F">Coordinate function F. Has to return double[3] {x, y, z}
            OR double[6] {x,y,z, normalX, normalY, normalZ}</param>
            <param name="umin">Minimum value of u coordinate.</param>
            <param name="umax">Maximum value of u coordinate.</param>
            <param name="vmin">Minimum value of v coordinate.</param>
            <param name="vmax">Maximum value of v coordinate.</param>
            <param name="uPts">Number of points in u partition.</param>
            <param name="vPts">Number of points in v partition.</param>
            <param name="cor">Color vector. x=red, y=green, z=blue. Goes from 0 to 1.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Create3DModel(System.String,System.Single[0:,0:][],System.Single[0:,0:][],System.Single[0:,0:][],OpenCLTemplate.CLGLInterop.Vector,System.Boolean)">
            <summary>Recreates 3D Model from calculated data</summary>
            <param name="Name">Model name.</param>
            <param name="VertENormal">Vertexes and normals to use to build model. float[,][3] - Only vertexes. float[6] - vertexes and normals</param>
            <param name="TexCoords">Texture coordinates. null - don't use. float[,][2] - coords</param>
            <param name="VertexColors">Vertex colors. null - don't use. float[,][4] - RGBA color</param>
            <param name="GlobalColor">Color vector. x=red, y=green, z=blue. Goes from 0 to 1.</param>
            <param name="LineModel">Is this a curve? (and not a surface)</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Create3DLine(System.String,OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CoordFuncXYZ,System.Single,System.Single,System.Int32,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Creates a 3D Line from parameterized equations</summary>
            <param name="Name">Line name</param>
            <param name="F">Coordinate function F. Has to return double[3] {x, y, z}
            OR double[6] {x,y,z, normalX, normalY, normalZ}. Notice that only u coordinate is passed (v=0).</param>
            <param name="umin">Minimum value of u coordinate.</param>
            <param name="umax">Maximum value of u coordinate.</param>
            <param name="uPts">Number of points in u partition.</param>
            <param name="cor">Color vector. x=red, y=green, z=blue. Goes from 0 to 1.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Create3DLine(System.String,System.Single[][],OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Creates a 3D Line from parameterized equations</summary>
            <param name="Name">Line name</param>
            <param name="VertENormal">Vertex and normal coordinates of curve</param>
            <param name="cor">Color vector. x=red, y=green, z=blue. Goes from 0 to 1.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.calcNormais(OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.area)">
            <summary>Calculates normal vectors of a given area.</summary>
            <param name="a">Area to calculate normal vectors</param>
            <remarks>It is not possible to know for sure the area orientation. 
            It would be better to give the normal vector.</remarks>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.calcCGBox">
            <summary>Calculates vertexes average (center of gravity) and lowest Z coordinate.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.suavizaNormais">
            <summary>Smooths normal vectors in order to get per-pixel normals
            and allow OpenGL to use Gouraud shading.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.ForceRedraw">
            <summary>Force element redraw?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.ShowModel">
            <summary>Show this model?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.vetTransl">
            <summary>Object translation vector from origin.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.vetRot">
            <summary>Object rotation vector in Euler angles (psi-theta-phi).</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.rad2deg">
            <summary>Radian to degree conversion</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Render(System.Boolean)">
            <summary>Renders this 3D Model. Returns next OpenGL list number to use
            if it was necessary to generate new lists.</summary>
            <param name="DesenharTransparentes">True to draw only transparent object. This is used to draw solid objects last.</param>
            <returns>Returns next OpenGL list number to use
            if it was necessary to generate new lists.</returns>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.desenhaPartes(System.Boolean)">
            <summary>Renders the parts of this 3D model.</summary>
            <param name="DesenharTransparentes">True to draw only transparent object. This is used to draw solid objects last.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.geraPoligonosParte(OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte,System.Object[]@)">
            <summary>Generates polygons for a given 3D Model part.</summary>
            <param name="p">Part to generate models to.</param>
            <param name="o">Object to hold information content o = new object[] { VertCoordsData, ColorData, TexCoordsData, ElementData, NormalsData }</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.ApplyTexture(System.Drawing.Bitmap)">
            <summary>Changes the texture of this object</summary>
            <param name="Bmp">New bitmap to apply</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.AplicaTextura">
            <summary>Applies texture if possible</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.ResizeToPowerOf2(System.Drawing.Image)">
            <summary>Method for resizing an image</summary>
            <param name="img">Image to resize</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Desloca(System.Int32,System.Double)">
            <summary>Displaces 3D model in a certain way.</summary>
            <param name="modo">Displacement model. 0=X axis, 1=Y axis, 2=Z axis,
            3=X rotation, 4=Y rotation, 5=Z rotation</param>
            <param name="desl">Displacement value. Distance or angle in radians.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Seleciona(System.Int32)">
            <summary>Draws desired part as selected.</summary>
            <param name="indParte">Part to select.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.DesSeleciona(System.Int32)">
            <summary>Stops drawing desired part as selected.</summary>
            <param name="indParte">Part to unselect.</param>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.modelMovement">
            <summary>Model vertexex move with time?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.ModelRenderStyle">
            <summary>Render style</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.area">
            <summary>Struct to hold a polygon area.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.area.IndVertices">
            <summary>List of indexes of vertexes that create this area.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.area.IndNormais">
            <summary>List of indexes of normal vectors of this area's vertexes.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.area.IndTexVertexes">
            <summary>List of indexes of texture vectors of this area's vertexes.</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Vertex">
            <summary>Struct to hold a polygon vertex.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Vertex._indAreas">
            <summary>List of indexes of areas that use this vertex.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Vertex._indParte">
            <summary>List of indexes of 3D model parts that use this vertex.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Vertex._indNormais">
            <summary>List of indexes of areas that use this vertex.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Vertex.Coords">
            <summary>Vertex coordinates.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Vertex.VertexColor">
            <summary>Vertex color, RGBA</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte">
            <summary>3D Model parts holder.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.Name">
            <summary>Part name.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.Areas">
            <summary>List of areas that belong to this part.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.Cor">
            <summary>Color of this area.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.Transparencia">
            <summary>Transparency of this area.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.Selecionar">
            <summary>Display this part as selected?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.GLListNumber">
            <summary>OpenGL list number of this part.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.GLBuffers">
            <summary>Buffer objects to use if the hardware supports buffer objects</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.GLNumElements">
            <summary>Number of elements to draw using buffer objects</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.#ctor(OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte)">
            <summary>Constructor. Copies a given part.</summary>
            <param name="p">Part to copy from.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Parte.#ctor">
            <summary>Empty constructor.</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CoordFuncXYZ">
            <summary>Delegate to create coordinates in the new 3D Model.</summary>
            <param name="u">Independent parameter u.</param>
            <param name="v">Independent parameter v.</param>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Example3DModels">
            <summary>Example 3D Models generated from equations.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Example3DModels.Cylinder(System.String,System.Single,System.Single,System.Int32,OpenCLTemplate.CLGLInterop.Vector,System.Drawing.Bitmap)">
            <summary>Generates a 3D Model for a cylinder.</summary>
            <param name="Name">Model name.</param>
            <param name="Radius">Cylinder radius.</param>
            <param name="Height">Cylinder height.</param>
            <param name="numPoints">Number of points for circular section.</param>
            <param name="Color">Color vector.</param>
            <param name="Texture">Texture bitmap. Null uses no texture</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Example3DModels.Cone(System.String,System.Single,System.Single,System.Int32,OpenCLTemplate.CLGLInterop.Vector,System.Drawing.Bitmap)">
            <summary>Generates a 3D Model for a cone.</summary>
            <param name="Name">Model name.</param>
            <param name="Radius">Cone outer radius.</param>
            <param name="Height">Cone height.</param>
            <param name="numPoints">Number of points for circular section.</param>
            <param name="Color">Color vector.</param>
            <param name="Texture">Texture bitmap. Null uses no texture</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Example3DModels.Sphere(System.String,System.Single,System.Int32,OpenCLTemplate.CLGLInterop.Vector,System.Drawing.Bitmap)">
            <summary>Generates a 3D Model for a sphere.</summary>
            <param name="Name">Model name.</param>
            <param name="numPoints">Number of points to use for each coordinate. At least 4.</param>
            <param name="Radius">Sphere radius.</param>
            <param name="Color">Color vector.</param>
            <param name="Texture">Texture bitmap. Null uses no texture</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.Example3DModels.Disk(System.String,System.Single,System.Single,System.Int32,OpenCLTemplate.CLGLInterop.Vector,System.Drawing.Bitmap)">
            <summary>Generates a 3D Model for a disk.</summary>
            <param name="Name">Model name.</param>
            <param name="numPoints">Number of points to use in circumference.</param>
            <param name="InnerRadius">Inner disk radius.</param>
            <param name="OuterRadius">Outer disk radius.</param>
            <param name="Color">Color vector.</param>
            <param name="Texture">Texture bitmap. Null uses no texture</param>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum">
            <summary>Enumerations for Lab3D file format</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelType">
            <summary>Model type</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelType.Curve">
            <summary>Model contains a curve</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelType.Surface">
            <summary>Model contains a surface</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelMovement">
            <summary>Model movement type</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelMovement.Static">
            <summary>Static model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelMovement.Dynamic">
            <summary>Vertex coords of the model change with time</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelTextureType">
            <summary>Lab3D model texture</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelTextureType.None">
            <summary>No texture</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelTextureType.FromText">
            <summary>Texture from text</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelTextureType.FromImage">
            <summary>Texture from image</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelQuality">
            <summary>Model number of points in u and v direction</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelQuality.Low">
            <summary>Low 30x30 model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelQuality.Medium">
            <summary>Medium 100x100 model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelQuality.High">
            <summary>High 200x200 model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelQuality.VeryHigh">
            <summary>Very high 400x400 model</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLModelQuality.Custom">
            <summary>Custom resolution</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLRenderStyle">
            <summary>Model render style</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLRenderStyle.Solid">
            <summary>Renders this model Solid</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLRenderStyle.Wireframe">
            <summary>Renders this model Wireframe</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLRender.GLVBOModel.Lab3DModelHolder.CLEnum.CLRenderStyle.Point">
            <summary>Renders this model as Point</summary>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.GLFont">
            <summary>OpenGL 3D font creator</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLFont.GLchars">
            <summary>Stores 3D character models</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLFont.referenceWidth">
            <summary>Reference width of letter O</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.GLFont.WidthInGLScale">
            <summary>Width of characters in OpenGL scale</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.#ctor(System.Drawing.Font,System.Single)">
            <summary>Creates a new 3D font from specified font</summary>
            <param name="f">Font prototype to use in this 3D font</param>
            <param name="GLNormalizationScale">Character reference width in OpenGL scale</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.#ctor(System.String)">
            <summary>Loads a 3D font from a file. Does NOT require OpenCL/GL interop</summary>
            <param name="filename">3D Font file</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.Draw3DString(System.String,OpenCLTemplate.CLGLInterop.GLRender)">
            <summary>Creates an array of 3D models containing the given string. If target!=null adds them to target`s display list</summary>
            <param name="s">String to write</param>
            <param name="target">Target GLWindow to write</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.Draw3DString(System.String)">
            <summary>Creates an array of 3D models containing the given string</summary>
            <param name="s">String to write</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.Save(System.String)">
            <summary>Saves this 3D font to a file. Requires OpenCL/GL interoperation.</summary>
            <param name="file">File to save to.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.DrawString(System.String,System.Drawing.Font,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color)">
            <summary>Returns a Bitmap containing a text drawn. Useful to set as texture.</summary>
            <param name="s">String to be written</param>
            <param name="TextFont">Font to use</param>
            <param name="TextLeftColor">Left color of Text.</param>
            <param name="TextRightColor">Right color of Text.</param>
            <param name="BackgroundLeftColor">Left color of Background.</param>
            <param name="BackgroundRightColor">Right color of Background.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.DrawString(System.String,System.Drawing.Font,System.Drawing.Color,System.Drawing.Color)">
            <summary>Returns a Bitmap containing a text drawn. Useful to set as texture.</summary>
            <param name="s">String to be written</param>
            <param name="TextFont">Font to use</param>
            <param name="TextColor">Text color.</param>
            <param name="BackgroundColor">Background color.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.GLFont.DrawString(System.String,System.Drawing.Font)">
            <summary>Returns a Bitmap containing a text drawn. Useful to set as texture.</summary>
            <param name="s">String to be written</param>
            <param name="TextFont">Font to use</param>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.CLGLInteropFunctions">
            <summary>Encapsulates functions needed to acquire and release OpenCL/GL shared objects</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.CLGLInteropFunctions.AcquireGLElements(OpenCLTemplate.CLCalc.Program.MemoryObject)">
            <summary>Acquires one OpenCL variable created from GL buffers in order to use it. Ignores variables not created from OpenGL buffer</summary>
            <param name="CLGLVar">Variable to be acquired</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.CLGLInteropFunctions.AcquireGLElements(OpenCLTemplate.CLCalc.Program.MemoryObject[])">
            <summary>Acquires OpenCL variables created from GL buffers in order to use them. Ignores variables not created from OpenGL buffer</summary>
            <param name="CLGLVars">Variables to be acquired</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.CLGLInteropFunctions.ReleaseGLElements(OpenCLTemplate.CLCalc.Program.MemoryObject)">
            <summary>Releases one OpenCL variable created from GL buffers. Ignores variables not created from OpenGL buffer</summary>
            <param name="CLGLVar">Variable to be released</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.CLGLInteropFunctions.ReleaseGLElements(OpenCLTemplate.CLCalc.Program.MemoryObject[])">
            <summary>Releases OpenCL variables created from GL buffers. Ignores variables not created from OpenGL buffer</summary>
            <param name="CLGLVars">Variables to be acquired</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.CLGLInteropFunctions.ApplyTexture(System.Drawing.Bitmap,System.Int32@)">
            <summary>Copies bitmap data to a OpenGL texture. Note: texture is flipped in Y axis, needs to correct texture coordinates</summary>
            <param name="TextureBitmap">Bitmap to be copied to OpenGL memory</param>
            <param name="ind">A valid OpenGL texture generated with GLGenTexture. If less than zero a new OpenGL texture is created and stored in ind</param>
        </member>
        <member name="T:OpenCLTemplate.CLGLInterop.Vector">
            <summary>Vector class with math operations and dot / cross products.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.Vector.x">
            <summary>Vector X component.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.Vector.y">
            <summary>Vector Y component.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLGLInterop.Vector.z">
            <summary>Vector Z component.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.#ctor">
            <summary>Constructor. Initializes zero vector.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.#ctor(System.Double,System.Double,System.Double)">
            <summary>Construtor. Initializes given values.</summary>
            <param name="xComponent">Vector X component.</param>
            <param name="yComponent">Vector Y component.</param>
            <param name="zComponent">Vector Z component.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.#ctor(OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Construtor. Copies a given vector.</summary>
            <param name="v">Vector to copy.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.ToString">
            <summary>Returns a string that represents this vector.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.op_Addition(OpenCLTemplate.CLGLInterop.Vector,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Vector sum.</summary>
            <param name="v1">First vector to sum.</param>
            <param name="v2">Second vector to sum.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.op_Subtraction(OpenCLTemplate.CLGLInterop.Vector,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Vector subtraction.</summary>
            <param name="v1">Vector to subtract from.</param>
            <param name="v2">Vector to be subtracted.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.op_Multiply(System.Double,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Vector scalar product.</summary>
            <param name="num">Scalar to multiply.</param>
            <param name="v">Vector to multiply.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.op_Multiply(OpenCLTemplate.CLGLInterop.Vector,System.Double)">
            <summary>Vector scalar product.</summary>
            <param name="num">Scalar to multiply.</param>
            <param name="v">Vector to multiply.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.op_Division(System.Double,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Vector scalar division.</summary>
            <param name="num">Scalar to divide by.</param>
            <param name="v">Vector to be divided.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.op_Division(OpenCLTemplate.CLGLInterop.Vector,System.Double)">
            <summary>Vector scalar division.</summary>
            <param name="num">Scalar to divide by.</param>
            <param name="v">Vector to be divided.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.CompareTo(OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Equality comparison.</summary>
            <param name="v">Vector to compare to.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.DotProduct(OpenCLTemplate.CLGLInterop.Vector,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Returns vector dot product.</summary>
            <param name="v1">First vector of Dot Product.</param>
            <param name="v2">Second vector of Dot Product.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.CrossProduct(OpenCLTemplate.CLGLInterop.Vector,OpenCLTemplate.CLGLInterop.Vector)">
            <summary>Returns vector cross product.</summary>
            <param name="v1">First vector of Cross Product.</param>
            <param name="v2">Second vector of Cross Product.</param>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.norm">
            <summary>Returns vector norm.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLGLInterop.Vector.normalize">
            <summary>Normalizes this vector.</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.CLObjClassifier">
            <summary>Object classifier Class</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.kernelExtractFeatures">
            <summary>Kernel to extract features</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.kernelSegregateSkin">
            <summary>Kernel to segregate skin</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.kernelComputeFrameDiff">
            <summary>Kernel to compute frame difference</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.#ctor(System.Boolean)">
            <summary>Constructor. Loads and classifies face dataset if desired</summary>
            <param name="TrainFaceDataset">Load and classify face dataset?</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.#ctor(System.String)">
            <summary>Constructor. Loads parameters from a file.</summary>
            <param name="svmFile">File to read</param>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.tSet">
            <summary>Training set for SVM</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.SVM">
            <summary>Face classification SVM</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.LoadMITFaceClassifier">
            <summary>Loads and classifies dataset</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.FillTrainingSet(System.String,OpenCLTemplate.MachineLearning.TrainingSet)">
            <summary>Adds training units to a set from a file</summary>
            <param name="filename">File containing features</param>
            <param name="TrSet">Training set to be populated</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.FindSingleObj(System.Drawing.Bitmap)">
            <summary>Specific function when SVM contains only one object, such as faces</summary>
            <param name="bmp">Next frame to process</param>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.imgWidth">
            <summary>Image dimensions</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.imgHeight">
            <summary>Image dimensions</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.SubFrames">
            <summary>Where to extract features in image</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.SubFramePos">
            <summary>Where to replace next subframe?</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.CLSubFrames">
            <summary>Where to extract features in OpenCL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.SubFeatures">
            <summary>Subimages features</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.CLSubFeatures">
            <summary>Subimage features in OpenCL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.CLBmp">
            <summary>Bitmap in device memory</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.CLBmpPrev">
            <summary>Previous bitmap in device memory</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.ComputeSubFrames(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>Computes subframe vector to check where to extract features</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.SelfTSet">
            <summary>Self training set</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.AddSelfTraining(System.Int32[],System.Int32,System.Drawing.Bitmap)">
            <summary>Adds a new self training example</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.SelfTrain">
            <summary>Trains SVM with self data</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.CLframeDiff">
            <summary>OpenCL memory frame difference</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.frameDiff">
            <summary>Frame difference</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.MovingRegionBoxes">
            <summary>Moving region boxes. List of boxes found [xmin0, xmax0, ymin0, ymax0, xmin1, xmax1, ....]</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.ComputeFrameDiff">
            <summary>Computes frame difference</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.BracketMovingRegions(System.Byte[],System.Int32,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>Tries to bracked moving regions</summary>
            <param name="FrameDiff">Frame difference matrix</param>
            <param name="fWidth">FrameDiff width</param>
            <param name="fHeight">FrameDiff height</param>
            <param name="boxes">List of boxes found [xmin0, xmax0, ymin0, ymax0, xmin1, xmax1, ....]</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.CLObjClassifier.BracketRegionAround(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean[],System.Int32[],System.Int32)">
            <summary>Brackets region around a box where displacement occurred</summary>
            <param name="x">X position (column) in FrameDiff Matrix</param>
            <param name="y">Y position (line) in FrameDiff Matrix</param>
            <param name="FrameDiff">Frame difference matrix</param>
            <param name="fWidth">Width of FrameDiff</param>
            <param name="fHeight">Height of FrameDiff</param>
            <param name="Visited">Visited elements of FrameDiff</param>
            <param name="box">Box containing boundaries of region [xmin, xmax, ymin, ymax]</param>
            <param name="Threshold">Threshold to consider as relevant difference region</param>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.CLObjClassifier.CLExtractFeatSrc">
            <summary>OpenCL source code to extract features</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.CLObjClassifier.CLBracketRegionsSrc">
            <summary>OpenCL source to bracket regions</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.CLObjClassifier.Config">
            <summary>Configuration</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.Config.WINDOWSIZES">
            <summary>Window sizes in pixels to use to look for objects</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.Config.OVERLAP">
            <summary>Extra coverage to use. E.g.: 10 windows would cover entire screen, algorithm uses OVERLAP * 10</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.Config.PIXELSIZE">
            <summary>Pixel size</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.Config.REQCERTAINTY">
            <summary>Only classifies as face if kernel value is above REQCERTAINTY</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.Config.REFINEUNCERTAINTY">
            <summary>Refine region if it looks like a face to this degree</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.Config.MOVEMENTTHRESHOLD">
            <summary>Threshold to consider as relevant movement</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.CLObjClassifier.Config.KEEPSEARCHTHRESHOLD">
            <summary>Threshold to consider as relevant movement to keep search</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.TrainingUnit">
            <summary>
            This class corresponds to a training unit of the training data with all its inputs and the desired output.
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.TrainingUnit.xVector">
            <summary>Features</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.TrainingUnit.y">
            <summary>Desired output (-1 or 1)</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.TrainingUnit.#ctor(System.Single[],System.Single)">
            <summary>Creates a new training unit</summary>
            <param name="newXVector">New unit</param>
            <param name="Classification">Classification, should ONLY be 1 or -1 for pure SVMs, write desired value for MultiClassSVMs</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.TrainingUnit.getDimension">
            <summary>Gets dimension of feature vector</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.TrainingUnit.Clone">
            <summary>Retuurns a new trainingUnit which is the clone of this one</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.SVM">
            <summary>
            This class stores the variables of a SMO problem solution
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.MAXMINWORKSIZE">
            <summary>Global work size to compute max/min. Has to be a power of 2</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLResource">
            <summary>Semaphor to ensure thread safety within OpenCL</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.CLSVMInit">
            <summary>Compiles code and initializes kernel for this svm stance</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelComputeKernelRBF">
            <summary>Computes RBF kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLTrainingFeatures">
            <summary>OpenCL training features matrix</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.TrainingFeatures">
            <summary>Host memory training features</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLXVecLen">
            <summary>Length of each training feature</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.HostVLen">
            <summary>Length of each training feature in host memory</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLSample">
            <summary>OpenCL feature sample</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.HostSample">
            <summary>OpenCL feature sample in Host Memory</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLKernelValues">
            <summary>Computed kernel values</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLLambda">
            <summary>Kernel lambda configuration parameter</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.WriteToDevice">
            <summary>Writes Training Set into device memory</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.CLcalculateAllKernels(OpenCLTemplate.MachineLearning.SVM)">
            <summary>Computes All kernels and errors accelerating with OpenCL</summary>
            <param name="problemSolution">Problem solution SVM</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.CLComputeKernels(OpenCLTemplate.MachineLearning.SVM,System.Int32)">
            <summary>Computes the i-th line of matrix K[i][j]</summary>
            <param name="problemSolution">SVM to solve</param>
            <param name="i">Kernel line number to compute</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.CLpredictOutput(OpenCLTemplate.MachineLearning.SVM,OpenCLTemplate.MachineLearning.TrainingUnit)">
            <summary>
            Predicts the output of a single entry, given a previous problem, solution and correspondent training set
            </summary>
            <param name="problemSolution">Correspondent problem solution</param>
            <param name="untrainedUnit">Input features from which the output will be predicted</param>
            <returns>The y classification (true/false = positive/negative)</returns>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelComputeMultiKernelRBF">
            <summary>CLKernel to compute multiple kernels</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelSumKernels">
            <summary>CLKernel to sum kernels to a final value</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLKernelValuesMultiClassify">
            <summary>Kernel values for multi classification</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLAlphas">
            <summary>Store svm`s alphas</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLys">
            <summary>Store svm`s y</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLb">
            <summary>Store svm`s b</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLQtdSupVecs">
            <summary>Number of support vectors</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLMultiClassifSums">
            <summary>Final multiclassification sums</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.MultiClassify(OpenCLTemplate.MachineLearning.SVM,OpenCLTemplate.CLCalc.Program.Image2D)">
            <summary>Classifies multiple samples stored in OpenCL memory</summary>
            <param name="Samples">Samples data to classify</param>
            <param name="svm">SVM to use as classifier</param>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelMaxErr">
            <summary>Kernel to compute maximum or minimum of a vector</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelMinErr">
            <summary>Kernel to compute maximum or minimum of a vector</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelComputeMax">
            <summary>Kernel to compute maximum or minimum of a vector</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelComputeMin">
            <summary>Kernel to compute maximum or minimum of a vector</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelGetResp">
            <summary>Gets max/min index from device</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLerr">
            <summary>OpenCL errors holder</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLErrLen">
            <summary>Error.Length</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLMaxMinErrs">
            <summary>Length MAXMINWORKSIZE vector containing local max/min</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLMaxMinInds">
            <summary>Length MAXMINWORKSIZE index list containing index of local max/min</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLResp">
            <summary>Length 1 containing final index value</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.HostResp">
            <summary>Host memory answer holder</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.kernelUpdateErr">
            <summary>Updates device memory errors based on newly calculated alphas</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLKi">
            <summary>Holders of kernel values</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLKj">
            <summary>Holders of kernel values</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CLUpdtErrParams">
            <summary>Update parameters: alphaNew-alphaOld, Bnew-Bold</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.CLFindMaxError(OpenCLTemplate.MachineLearning.SVM)">
            <summary>Finds maximum E[i] in SVM and returns corresponding i (returns arg max E[i])</summary>
            <param name="svm">SVM to check</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.CLFindMinError(OpenCLTemplate.MachineLearning.SVM)">
            <summary>Finds minimum E[i] in SVM and returns corresponding i (returns arg min E[i])</summary>
            <param name="svm">SVM to check</param>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.TrainingSet">
            <summary>Training set for this solution</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.ProblemCfg">
            <summary>Problem configuration</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.alphaList">
            <summary>
            Lagrange multipliers for solution
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.b">
            <summary>
            Threshold for solution
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.dimension">
            <summary>
            The dimension of the training set for which this is a solution
            </summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.#ctor">
            <summary>
             Constructor that initializes with 0s
            </summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.initializeWithZeros">
            <summary>
            Set all values of the solution to 0
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.CrossValParams">
            <summary>Cross validation parameters: [0] - maximum crossValidation value found so far, [1] - lambda, [2] - C.  Returns best performance so far</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.PreCalibrateCfg(System.Single,System.Single)">
            <summary>Attempts to pre-calibrate configuration parameters.
            Finds an alpha that enhances similarities between positive examples
            and reduces similarities between positive and negative examples.
            Assumes that decreasing lambda increases kernel match.
            </summary>
            <param name="tolPositive">Positive kernels average should be greater than tolPositive</param>
            <param name="tolNegative">Negative kernels average should be lesser than tolNegative</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.TrainWithCrossValidation">
            <summary>Trains current SVM with cross-validation, adjusting kernel parameter lambda and box parameter C</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.TrainWithCrossValidation(System.Single,System.Single[],System.Single[])">
            <summary>Trains current SVM with cross-validation, adjusting kernel parameter lambda and box parameter C. Returns best performance so far</summary>
            <param name="CrossValidationSetPercent">Percentage of training examples that should be used as cross validation set</param>
            <param name="lambdaSet">Values of lambda to try</param>
            <param name="CSet">Values of c to try</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.Train">
            <summary>Trains current SVM</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.PreComputeKernels">
            <summary>Precomputes kernels of training set</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.ResetSolution">
            <summary>Resets current SVM solution</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.RemoveNonSupportVectors">
            <summary>Removes all vectors that are not SVMs, ie, so that alpha[i]=0</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.Classify(OpenCLTemplate.MachineLearning.TrainingUnit)">
            <summary>Classifies a training unit as positive or negative (true or false)</summary>
            <param name="Sample">Sample to be classified</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.ClassificationValue(OpenCLTemplate.MachineLearning.TrainingUnit)">
            <summary>Classifies a training unit with a float. The bigger, the more positive the sample. Values greater than zero
            are assumed to be positive samples</summary>
            <param name="Sample">Sample to be classified</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.GetTrainingSetHitRate">
            <summary>Gets the percentage of training examples classified correctly in the training set</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.GetTrainingSetHitRate(System.Int32)">
            <summary>Gets the percentage of training examples classified correctly starting from the ind-th training sample</summary>
            <param name="ind">Index to start reading training set samples</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.GetHitRate(OpenCLTemplate.MachineLearning.TrainingSet)">
            <summary>Computes hit rates for a given test set</summary>
            <param name="samples">Test set to be used</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.Load(System.String)">
            <summary>
            Copy all values from another solution
            </summary>
            <param name="FileName">File containing alpha's data</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.Save(System.String)">
            <summary>Writes current solution to a file</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.SVM.ProblemSolver">
            <summary>
            This class aggregates all methods for solving SMO problems
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.SVM.ProblemSolver.MIN_ALPHA_CHANGE">
            <summary>
            Minimal alpha variation to optimize
            </summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.ProblemSolver.solveSMOStartingFromZero(OpenCLTemplate.MachineLearning.SVM)">
            <summary>
            Solves the SMO considering no previous knowledge about the problem
            </summary>
            <param name="problemSolution">Solution of the problem</param>
            <returns>Solution of the problem with alphas and threshold</returns>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.ProblemSolver.solveSMOStartingFromPreviousSolution(OpenCLTemplate.MachineLearning.SVM)">
            <summary>
            Solves the SMO considering no previous knowledge about the problem
            </summary>
            <param name="problemSolution">Known solution</param>
            <returns>Solution of the problem with alphas and threshold</returns>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.ProblemSolver.predictOutput(OpenCLTemplate.MachineLearning.SVM,OpenCLTemplate.MachineLearning.TrainingUnit)">
            <summary>
            Predicts the output of a single entry, given a previous problem, solution and correspondent training set
            </summary>
            <param name="problemSolution">Correspondent problem solution</param>
            <param name="untrainedUnit">Input features from which the output will be predicted</param>
            <returns>The y classification (true/false = positive/negative)</returns>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.SVM.ProblemSolver.ComputeKernels(OpenCLTemplate.MachineLearning.SVM,System.Int32)">
            <summary>Computes the i-th line of matrix K[i][j]</summary>
            <param name="problemSolution">SVM to solve</param>
            <param name="i">Kernel line number to compute</param>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.MultiClassSVM">
            <summary>Multiple training SVM</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.MultiClassSVM.Classifications">
            <summary>List of possible classifications</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.MultiClassSVM.SVMs">
            <summary>SVMs to perform each classification</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.#ctor(OpenCLTemplate.MachineLearning.TrainingSet)">
            <summary>Creates a new multiclass SVM using desired outputs from training set. Classifications -1.0f are negative for all sets</summary>
            <param name="TSet">Training set</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.#ctor(OpenCLTemplate.MachineLearning.TrainingSet,OpenCLTemplate.MachineLearning.ProblemConfig,System.Boolean)">
            <summary>Creates a new multiclass SVM using desired outputs from training set. Classifications -1.0f are negative for all sets</summary>
            <param name="TSet">Training set</param>
            <param name="SVMCfg">Configuration parameters</param>
            <param name="PreCalibrate">Precalibrate RBF parameter lambda? This will ignore the given value</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.initMultiSVM(OpenCLTemplate.MachineLearning.TrainingSet,OpenCLTemplate.MachineLearning.ProblemConfig,System.Boolean)">
            <summary>Creates a new multiclass SVM using desired outputs from training set. Classifications -1.0f are negative for all sets</summary>
            <param name="TSet">Training set</param>
            <param name="SVMCfg">Configuration parameters</param>
            <param name="PreCalibrate">Precalibrate RBF parameter lambda? This will ignore the given value</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.Train">
            <summary>Trains all SVMs in this multiclass SVM</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.Train(System.Single,System.Single)">
            <summary>Trains all SVMs in this multiclass SVM precalibrating kernels</summary>
            <param name="tolPositive">Positive kernels average should be greater than tolPositive</param>
            <param name="tolNegative">Negative kernels average should be lesser than tolNegative</param>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.MultiClassSVM.CrossValParams">
            <summary>Cross validation parameters: [0] - maximum crossValidation value found so far, [1] - lambda, [2] - C.  Returns best performance so far</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.TrainWithCrossValidation(OpenCLTemplate.MachineLearning.TrainingSet)">
            <summary>Trains current SVM with cross-validation, adjusting kernel parameter lambda and box parameter C.
            Returns best achieved efficiency.</summary>
            <param name="CrossValidationSet">Cross validation set</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.TrainWithCrossValidation(OpenCLTemplate.MachineLearning.TrainingSet,System.Single[],System.Single[])">
            <summary>Trains current SVM with cross-validation, adjusting kernel parameter lambda and box parameter C.
            Returns best achieved efficiency.</summary>
            <param name="CrossValidationSet">Cross validation set</param>
            <param name="LambdaSet">Lambda set</param>
            <param name="CSet">C values set</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.GetCrossValidationSet(OpenCLTemplate.MachineLearning.TrainingSet,System.Single)">
            <summary>Extracts a cross validation set from a given set</summary>
            <param name="Set">Set to extract cross validation from</param>
            <param name="CrossValidationSetPercent">Percentage of elements to extract</param>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.MultiClassSVM.sample">
            <summary>Sample to classify</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.MultiClassSVM.ClassificationValues">
            <summary>Returned classification values</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.ClassifyWithRejection(OpenCLTemplate.MachineLearning.TrainingUnit)">
            <summary>Attempts to classify a sample within a given category. Returns -1 if no classification was achieved.</summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.Classify(OpenCLTemplate.MachineLearning.TrainingUnit,System.Single@)">
            <summary>Classifies a sample within a given category even if all SVMs predict it doesn`t belong to any.</summary>
            <param name="Sample">Sample to classify</param>
            <param name="maxVal">Maximum classification value found</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.Classify(OpenCLTemplate.CLCalc.Program.Image2D,System.Single[]@)">
            <summary>Classifies a given set of Samples (image2d of floats) each one in a category. Each row of the image is a sample
            to be classified and the features should be stored in the columns. The number of columns Ncol = Nfeatures/4 since 
            each pixel holds 4 floats</summary>
            <param name="Samples">Image2D containing samples to be classified</param>
            <param name="maxVals">Maximum values found</param>
            <returns></returns>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.Classify(System.Object)">
            <summary>Classifies a sample using i-th svm</summary>
            <param name="SVMInd">(int) Index of svm to use</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.GetHitRate(OpenCLTemplate.MachineLearning.TrainingSet)">
            <summary>Gets SVM hit rate</summary>
            <param name="TestSet">Test set</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.MultiClassSVM.GetInternalHitRate">
            <summary>Gets average internal hit rate</summary>
        </member>
        <member name="T:OpenCLTemplate.Isosurface.MarchingCubes">
            <summary>Marching cubes algorithm for isosurface reconstruction</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.ComputeNormals">
            <summary>Compute normals of faces?</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.step">
            <summary>X, y and z increments. step[0] = deltaX, step[1] = deltaY, step[2] = deltaZ</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.initVals">
            <summary>X, y and z initial values. initVals[0] = x0, initVals[1] = y0, initVals[2] = z0</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.isoLevel">
            <summary>Isolevel to look for</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.funcVals">
            <summary>Values of the function</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.max">
            <summary>Length of each dimension - max[0] = maxX, max[1]=maxY, max[2]=maxZ</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.edgeCoords">
            <summary>Edge coordinates.</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.edgeNormals">
            <summary>Edge normals.</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.edgePrelimNormals">
            <summary>Edge coordinates.</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.elementIndex">
            <summary>Element index to build triangles</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.varIsoLevel">
            <summary>CL variable isolevel</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.CLFuncVals">
            <summary>OpenCL variable that stores function values. F(x,y,z) = CLFuncVals[x+maxX*y+maxX*maxY*z]</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.varEdgeCoords">
            <summary>CL Edge coordinates. Geometry data compatible with OpenGL</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.varEdgeNormals">
            <summary>CL Edge normals. Geometry data compatible with OpenGL</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.varElemIndex">
            <summary>CL Element index array. Geometry data compatible with OpenGL</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.varEdgePrelimNormals">
            <summary>Auxiliary/preliminary normals</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.varStep">
            <summary>OpenCL x, y and z step sizes</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.varInitVals">
            <summary>OpenCL x, y and z initial values within grid</summary>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.kernelInterpPts">
            <summary>Kernel to interpolate points</summary>
        </member>
        <member name="M:OpenCLTemplate.Isosurface.MarchingCubes.#ctor(System.Single[0:,0:,0:])">
            <summary>Creates a new isosurface calculator. You may pass variables created from a OpenGL context to the CL variables if you are using interop or NULL
            if not using OpenCL/GL interop.</summary>
            <param name="FuncValues">Values of the evaluated 3D function f(x,y,z). FuncValues=float[maxX,maxY,maxZ]</param>
        </member>
        <member name="M:OpenCLTemplate.Isosurface.MarchingCubes.#ctor(System.Single[0:,0:,0:],OpenCLTemplate.CLCalc.Program.Variable,OpenCLTemplate.CLCalc.Program.Variable,OpenCLTemplate.CLCalc.Program.Variable)">
            <summary>Creates a new isosurface calculator. You may pass variables created from a OpenGL context to the CL variables if you are using interop or NULL
            if not using OpenCL/GL interop.</summary>
            <param name="FuncValues">Values of the evaluated 3D function f(x,y,z). FuncValues=float[maxX,maxY,maxZ]</param>
            <param name="CLEdgeCoords">OpenCL variable (float) to hold edge coordinates. Dimension has to be 9 * maxX * maxY * maxZ</param>
            <param name="CLEdgeNormals">OpenCL variable (float) to hold edge normals. Dimension has to be 9 * maxX * maxY * maxZ</param>
            <param name="CLElementArrayIndex">OpenCL variable (int) to hold element array index. Dimension has to be 5 * 3 * (maxX - 1) * (maxY - 1) * (maxZ - 1)</param>
        </member>
        <member name="M:OpenCLTemplate.Isosurface.MarchingCubes.InitMarchingCubes(System.Single[0:,0:,0:],OpenCLTemplate.CLCalc.Program.Variable,OpenCLTemplate.CLCalc.Program.Variable,OpenCLTemplate.CLCalc.Program.Variable)">
            <summary>Creates a new isosurface calculator. You may pass variables created from a OpenGL context to the CL variables if you are using interop or NULL
            if not using OpenCL/GL interop.</summary>
            <param name="FuncValues">Values of the evaluated 3D function f(x,y,z). FuncValues=float[maxX,maxY,maxZ]</param>
            <param name="CLEdgeCoords">OpenCL variable (float) to hold edge coordinates. Dimension has to be 9 * maxX * maxY * maxZ</param>
            <param name="CLEdgeNormals">OpenCL variable (float) to hold edge normals. Dimension has to be 9 * maxX * maxY * maxZ</param>
            <param name="CLElementArrayIndex">OpenCL variable (int) to hold element array index. Dimension has to be 5 * 3 * (maxX - 1) * (maxY - 1) * (maxZ - 1)</param>
        </member>
        <member name="M:OpenCLTemplate.Isosurface.MarchingCubes.SetFuncVals(System.Single[0:,0:,0:])">
            <summary>Sets function values</summary>
            <param name="FuncVals">Values to set</param>
        </member>
        <member name="M:OpenCLTemplate.Isosurface.MarchingCubes.CalcIsoSurface(System.Single)">
            <summary>Calculates isosurface corresponding to a given isolevel</summary>
            <param name="isoLvl"></param>
        </member>
        <member name="F:OpenCLTemplate.Isosurface.MarchingCubes.edges">
            <summary>Remaps edge coordinates so that ElemArray[ edges[elementIndex[i]] ] points to the same coordinates as elementIndex[i]</summary>
        </member>
        <member name="M:OpenCLTemplate.Isosurface.MarchingCubes.GetEdgeInfo(System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>Retrieves edge information. Can be used to draw marching cubes geometry using OpenGL</summary>
            <param name="EdgeCoords">Edge vertexes coordinates</param>
            <param name="EdgeNormals">Edge vertexes normal vectors</param>
            <param name="ElemArray">Element index array (triangles)</param>
        </member>
        <member name="P:OpenCLTemplate.Isosurface.MarchingCubes.Increments">
            <summary>Gets or sets x, y and z increments. Increments[0] = deltaX, Increments[1] = deltaY, Increments[2] = deltaZ</summary>
        </member>
        <member name="P:OpenCLTemplate.Isosurface.MarchingCubes.InitValues">
            <summary>Gets or sets x, y and z intial values. InitValues[0] = x0, InitValues[1] = y0, InitValues[2] = z0</summary>
        </member>
        <member name="P:OpenCLTemplate.Isosurface.MarchingCubes.IsoLevel">
            <summary>Gets or sets current isolevel</summary>
        </member>
        <member name="T:Utility.ModifyRegistry.ModifyRegistry">
            <summary>
            An useful class to read/write/delete/count registry keys
            </summary>
        </member>
        <member name="M:Utility.ModifyRegistry.ModifyRegistry.Read(System.String)">
            <summary>
            To read a registry key.
            input: KeyName (string)
            output: value (string) 
            </summary>
        </member>
        <member name="M:Utility.ModifyRegistry.ModifyRegistry.Write(System.String,System.Object)">
            <summary>
            To write into a registry key.
            input: KeyName (string) , Value (object)
            output: true or false 
            </summary>
        </member>
        <member name="M:Utility.ModifyRegistry.ModifyRegistry.DeleteKey(System.String)">
            <summary>
            To delete a registry key.
            input: KeyName (string)
            output: true or false 
            </summary>
        </member>
        <member name="M:Utility.ModifyRegistry.ModifyRegistry.DeleteSubKeyTree">
            <summary>
            To delete a sub key and any child.
            input: void
            output: true or false 
            </summary>
        </member>
        <member name="M:Utility.ModifyRegistry.ModifyRegistry.SubKeyCount">
            <summary>
            Retrive the count of subkeys at the current key.
            input: void
            output: number of subkeys
            </summary>
        </member>
        <member name="M:Utility.ModifyRegistry.ModifyRegistry.ValueCount">
            <summary>
            Retrive the count of values in the key.
            input: void
            output: number of keys
            </summary>
        </member>
        <member name="P:Utility.ModifyRegistry.ModifyRegistry.ShowError">
            <summary>
            A property to show or hide error messages 
            (default = false)
            </summary>
        </member>
        <member name="P:Utility.ModifyRegistry.ModifyRegistry.SubKey">
            <summary>
            A property to set the SubKey value
            (default = "SOFTWARE\\" + Application.ProductName.ToUpper())
            </summary>
        </member>
        <member name="P:Utility.ModifyRegistry.ModifyRegistry.BaseRegistryKey">
            <summary>
            A property to set the BaseRegistryKey value.
            (default = Registry.LocalMachine)
            </summary>
        </member>
        <member name="T:OpenCLTemplate.frmCLEdit">
            <summary>OpenCL Helper Editor</summary>
        </member>
        <member name="M:OpenCLTemplate.frmCLEdit.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:OpenCLTemplate.frmCLEdit.btnCompileTest_Click(System.Object,System.EventArgs)">
            <summary>Button to test code</summary>
        </member>
        <member name="F:OpenCLTemplate.frmCLEdit.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:OpenCLTemplate.frmCLEdit.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:OpenCLTemplate.frmCLEdit.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:OpenCLTemplate.DifferentialEquations.floatODE46">
            <summary>Float differential equation integrator</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.floatODE46.KernelFinalizeCalc">
            <summary>Writes final Y values and estimated absolute errors</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.floatODE46.KernelUpdateX">
            <summary>Updates X to current time</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.floatODE46.x">
            <summary>Independent variable current value in OpenCL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.floatODE46.y">
            <summary>Dynamic system current state in OpenCL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.floatODE46.Derivs">
            <summary>Derivative calculator</summary>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.floatODE46.#ctor(System.Single,System.Single,System.Single[],OpenCLTemplate.DifferentialEquations.floatODE46.DerivCalcDeleg)">
            <summary>Constructor.</summary>
            <param name="InitialState">Initial state of system</param>
            <param name="StepSize">Desired step per integration pass</param>
            <param name="InitialIndepVarValue">Initial independent variable value</param>
            <param name="DerivativeCalculator">Function to calculate derivatives vector</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.floatODE46.Integrate(System.Single)">
            <summary>Integrates equation set to a final value using current stepsize. Ideally, final value 
            and currentX should multiples of stepsize.</summary>
            <param name="FinalValue">Final value to reach.</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.floatODE46.ResetState(System.Single,System.Single[])">
            <summary>Sets current state</summary>
            <param name="indepVar">New independent variable value</param>
            <param name="State">New state values</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.floatODE46.Step(System.Single)">
            <summary>Takes an integration step. Saves and returns stepsize back to what it was.</summary>
            <param name="StepSize">Step size to use</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.floatODE46.Step">
            <summary>Takes an integration step</summary>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.floatODE46.SetStep(System.Single)">
            <summary>Sets step size.</summary>
            <param name="StepSize">Step size to use</param>
        </member>
        <member name="P:OpenCLTemplate.DifferentialEquations.floatODE46.State">
            <summary>Gets current values of space-state variables (from Device).</summary>
        </member>
        <member name="P:OpenCLTemplate.DifferentialEquations.floatODE46.AbsError">
            <summary>Gets current absolute error sum</summary>
        </member>
        <member name="P:OpenCLTemplate.DifferentialEquations.floatODE46.IndepVar">
            <summary>Gets current independent variable value (from Device).</summary>
        </member>
        <member name="T:OpenCLTemplate.DifferentialEquations.floatODE46.DerivCalcDeleg">
            <summary>Function to calculate derivatives vector</summary>
            <param name="x">IN: Scalar. Independent variable.</param>
            <param name="y">IN: State-space vector.</param>
            <param name="dydx">OUT: Derivatives</param>
        </member>
        <member name="T:OpenCLTemplate.DifferentialEquations.floatODE46.ODE46Source">
            <summary>OpenCL source</summary>
        </member>
        <member name="T:OpenCLTemplate.DifferentialEquations.doubleODE46">
            <summary>double differential equation integrator</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.doubleODE46.KernelFinalizeCalc">
            <summary>Writes final Y values and estimated absolute errors</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.doubleODE46.KernelUpdateX">
            <summary>Updates X to current time</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.doubleODE46.x">
            <summary>Independent variable current value in OpenCL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.doubleODE46.y">
            <summary>Dynamic system current state in OpenCL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.DifferentialEquations.doubleODE46.Derivs">
            <summary>Derivative calculator</summary>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.doubleODE46.#ctor(System.Double,System.Double,System.Double[],OpenCLTemplate.DifferentialEquations.doubleODE46.DerivCalcDeleg)">
            <summary>Constructor.</summary>
            <param name="InitialState">Initial state of system</param>
            <param name="StepSize">Desired step per integration pass</param>
            <param name="InitialIndepVarValue">Initial independent variable value</param>
            <param name="DerivativeCalculator">Function to calculate derivatives vector</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.doubleODE46.Integrate(System.Double)">
            <summary>Integrates equation set to a final value using current stepsize. Ideally, final value 
            and currentX should multiples of stepsize.</summary>
            <param name="FinalValue">Final value to reach.</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.doubleODE46.ResetState(System.Double,System.Double[])">
            <summary>Sets current state</summary>
            <param name="indepVar">New independent variable value</param>
            <param name="State">New state values</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.doubleODE46.Step(System.Double)">
            <summary>Takes an integration step. Saves and returns stepsize back to what it was.</summary>
            <param name="StepSize">Step size to use</param>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.doubleODE46.Step">
            <summary>Takes an integration step</summary>
        </member>
        <member name="M:OpenCLTemplate.DifferentialEquations.doubleODE46.SetStep(System.Double)">
            <summary>Sets step size.</summary>
            <param name="StepSize">Step size to use</param>
        </member>
        <member name="P:OpenCLTemplate.DifferentialEquations.doubleODE46.State">
            <summary>Gets current values of space-state variables (from Device).</summary>
        </member>
        <member name="P:OpenCLTemplate.DifferentialEquations.doubleODE46.AbsError">
            <summary>Gets current absolute error sum</summary>
        </member>
        <member name="P:OpenCLTemplate.DifferentialEquations.doubleODE46.IndepVar">
            <summary>Gets current independent variable value (from Device).</summary>
        </member>
        <member name="T:OpenCLTemplate.DifferentialEquations.doubleODE46.DerivCalcDeleg">
            <summary>Function to calculate derivatives vector</summary>
            <param name="x">IN: Scalar. Independent variable.</param>
            <param name="y">IN: State-space vector.</param>
            <param name="dydx">OUT: Derivatives</param>
        </member>
        <member name="T:OpenCLTemplate.DifferentialEquations.doubleODE46.ODE46Source">
            <summary>OpenCL source</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.TrainingSet">
            <summary>
            This class encapsulates all training data.
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.TrainingSet.trainingArray">
            <summary>
            List of training units
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.TrainingSet.kernels">
            <summary>Auxiliar variable used during training, kernels values</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.TrainingSet.IsKernelCalculated">
            <summary>Is kernel K[i][p], p=0..n, calculated?</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.TrainingSet.errors">
            <summary>
            Auxiliar variable used during training
            </summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.TrainingSet.addTrainingUnit(OpenCLTemplate.MachineLearning.TrainingUnit)">
            <summary>Adds a new training unit to the set</summary>
            <param name="newTrainingUnit">New training unit to add</param>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.TrainingSet.rnd">
            <summary>
            Random number generator
            </summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.TrainingSet.removeRandomTrainingUnit">
            <summary>Removes a random training unit from the set</summary>
        </member>
        <member name="P:OpenCLTemplate.MachineLearning.TrainingSet.getN">
            <summary>
            Gets the number of elements in the training set (equivalent to trainingArray.Count)
            </summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.ProblemConfig">
            <summary>
            This class stores all variables related to the configuration of a SMO problem
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.c">
            <summary>Regularization parameter</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.lambda">
            <summary>Kernel parameter</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.tol">
            <summary>
            Numerical tolerance
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.maxPasses">
            <summary>
            Max # of times to iterate over alphas without changing
            </summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.kernelType">
            <summary>
            Set type of kernel function (default 2)
            </summary>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.ProblemConfig.#ctor(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Constructor with the default kernel
            </summary>
            <param name="Lambda">Kernel parameter</param>
            <param name="newC">Regularization parameter</param>
            <param name="newTol">Numerical tolerance</param>
            <param name="newMaxPasses">Max # of times to iterate over alphas without changing</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.ProblemConfig.#ctor(System.Single,System.Single,System.Single,System.Int32,OpenCLTemplate.MachineLearning.ProblemConfig.KernelType)">
            <summary>
            Constructor
            </summary>
            <param name="Lambda">Kernel parameter</param>
            <param name="newC">Regularization parameter</param>
            <param name="newTol">Numerical tolerance</param>
            <param name="newMaxPasses">Max # of times to iterate over alphas without changing</param>
            <param name="newKernelType">Type of kernel function index</param>
        </member>
        <member name="M:OpenCLTemplate.MachineLearning.ProblemConfig.Clone">
            <summary>Creates a new object equal to this</summary>
        </member>
        <member name="T:OpenCLTemplate.MachineLearning.ProblemConfig.KernelType">
            <summary>Type of SVM kernel to use</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.KernelType.Linear">
            <summary>Linear: u'*v</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.KernelType.Polynomial">
            <summary>Polynomial: (gamma*u'*v + coef0)^degree</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.KernelType.RBF">
            <summary>Radial basis function: exp(-gamma*||u[i]-v[i]||²)</summary>
        </member>
        <member name="F:OpenCLTemplate.MachineLearning.ProblemConfig.KernelType.Sigmoid">
            <summary>Sigmoid: tanh(gamma*u'*v + coef0)</summary>
        </member>
        <member name="M:OpenCLTemplate.Program.Main">
            <summary>
            The main entry point for the application.
            </summary>
        </member>
        <member name="T:OpenCLTemplate.FourierTransform.CLFFTfloat">
            <summary>Computes Fast Fourier Transform of floats</summary>
        </member>
        <member name="F:OpenCLTemplate.FourierTransform.CLFFTfloat.kernelfft_radix16">
            <summary>Radix FFT kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.FourierTransform.CLFFTfloat.kernelfft_radix4">
            <summary>Radix FFT kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.FourierTransform.CLFFTfloat.kernelConjugate">
            <summary>Radix FFT kernel</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.FFT16(OpenCLTemplate.CLCalc.Program.Variable@)">
            <summary>Computes the Discrete Fourier Transform of a float2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.FFT16(System.Single[])">
            <summary>Computes the Discrete Fourier Transform of a float2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.iFFT16(System.Single[])">
            <summary>Computes the inverse Discrete Fourier Transform of a float2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.iFFT16(OpenCLTemplate.CLCalc.Program.Variable)">
            <summary>Computes the inverse Discrete Fourier Transform of a float2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.FFT4(OpenCLTemplate.CLCalc.Program.Variable@)">
            <summary>Computes the Discrete Fourier Transform of a float2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.FFT4(System.Single[])">
            <summary>Computes the Discrete Fourier Transform of a float2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.iFFT4(System.Single[])">
            <summary>Computes the inverse Discrete Fourier Transform of a float2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTfloat.iFFT4(OpenCLTemplate.CLCalc.Program.Variable)">
            <summary>Computes the inverse Discrete Fourier Transform of a float2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="T:OpenCLTemplate.FourierTransform.CLFFTfloat.CLFFTSrc">
            <summary>Fast Fourier Transform source code</summary>
        </member>
        <member name="T:OpenCLTemplate.FourierTransform.CLFFTdouble">
            <summary>Computes Fast Fourier Transform of doubles</summary>
        </member>
        <member name="F:OpenCLTemplate.FourierTransform.CLFFTdouble.kernelfft_radix16">
            <summary>Radix FFT kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.FourierTransform.CLFFTdouble.kernelfft_radix4">
            <summary>Radix FFT kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.FourierTransform.CLFFTdouble.kernelConjugate">
            <summary>Radix FFT kernel</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.FFT16(OpenCLTemplate.CLCalc.Program.Variable@)">
            <summary>Computes the Discrete Fourier Transform of a double2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.FFT16(System.Double[])">
            <summary>Computes the Discrete Fourier Transform of a double2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.iFFT16(System.Double[])">
            <summary>Computes the inverse Discrete Fourier Transform of a double2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.iFFT16(OpenCLTemplate.CLCalc.Program.Variable)">
            <summary>Computes the inverse Discrete Fourier Transform of a double2 vector x whose length is a power of 16. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 16 (Length = 2*pow(16,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.FFT4(OpenCLTemplate.CLCalc.Program.Variable@)">
            <summary>Computes the Discrete Fourier Transform of a double2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.FFT4(System.Double[])">
            <summary>Computes the Discrete Fourier Transform of a double2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.iFFT4(System.Double[])">
            <summary>Computes the inverse Discrete Fourier Transform of a double2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="M:OpenCLTemplate.FourierTransform.CLFFTdouble.iFFT4(OpenCLTemplate.CLCalc.Program.Variable)">
            <summary>Computes the inverse Discrete Fourier Transform of a double2 vector x whose length is a power of 4. 
            x = { Re[x0] Im[x0] Re[x1] Im[x1] ... Re[xn] Im[xn] }, n = power of 4 (Length = 2*pow(4,n))</summary>
        </member>
        <member name="T:OpenCLTemplate.FourierTransform.CLFFTdouble.CLFFTSrc">
            <summary>Fast Fourier Transform source code</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc">
            <summary>OpenCL calculations class</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.dblInclude">
            <summary>String to include to enable Double Precision calculations</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLAccel">
            <summary>Currently used acceleration</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLInitErr">
            <summary>Initialization error</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.DisableCL">
            <summary>Sets CLCalc status to NotUsingCL</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.InitCL">
            <summary>Initializes OpenCL and reads devices</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.InitCL(Cloo.ComputeDeviceTypes)">
            <summary>Initializes OpenCL and reads devices</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.InitCL(Cloo.ComputeDeviceTypes,System.Int32)">
            <summary>Initializes OpenCL and reads devices</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.InitCL(Cloo.ComputeDeviceTypes,Cloo.ComputeContext,Cloo.ComputeCommandQueue,System.Int32)">
            <summary>Initializes OpenCL and reads devices. Uses previously created context and command queue if supplied. In that case DevicesToUse is ignored.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPlatforms">
            <summary>List of available platforms</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLDevices">
            <summary>List of available devices</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.EnableDblSupport">
            <summary>Gets string to include to enable Double Precision calculations</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.CLAcceleration">
            <summary>Gets acceleration type being used</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.CLInitError">
            <summary>Gets initialization error description</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.CLAccelerationType">
            <summary>OpenCL accelerations</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLAccelerationType.Unknown">
            <summary>Has not tested what type of acceleration is going to be used.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLAccelerationType.UsingCL">
            <summary>OpenCL used to accelerate calculations</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLAccelerationType.NotUsingCL">
            <summary>No OpenCL used/supported</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.Program">
            <summary>Program related stuff</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.Context">
            <summary>OpenCL context. Devices depend on how InitCL() was used.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.CommQueues">
            <summary>Synchronous command queues that are executed in call order</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.AsyncCommQueues">
            <summary>Asynchronous command queues</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.DefaultCQ">
            <summary>Default synchronous command queue set as the first GPU, for ease of use.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.Prog">
            <summary>Compiled program</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Sync">
            <summary>Ends all commands being executed</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.LoadSourceCode(System.String,System.String)">
            <summary>Loads a .CL program file and prepends the cPreamble to the code.</summary>
            <summary>Throws FileNotFoundException.</summary>
            <param name="FileName">Program filename</param>
            <param name="Preamble">Code that is prepended to the loaded file</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.LoadSourceCode(System.String)">
            <summary>Loads a .CL program file</summary>
            <summary>Throws FileNotFoundException.</summary>
            <param name="FileName">Program filename</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Compile(System.String)">
            <summary>Compiles program contained in a single string.</summary>
            <param name="SourceCode">Source code to compile</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Compile(System.String,System.Collections.Generic.List{System.String}@)">
            <summary>Compiles program contained in a single string. Returns build logs for each device.</summary>
            <param name="SourceCode">Source code to compile</param>
            <param name="BuildLogs">Build logs for each device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Compile(System.String[])">
            <summary>Compiles the program.</summary>
            <param name="SourceCode">Source code to compile</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Compile(System.String[],System.Collections.Generic.List{System.String}@)">
            <summary>Compiles the program. Returns the build logs for each device.</summary>
            <param name="SourceCode">Source code array to compile</param>
            <param name="BuildLogs">Build logs for each device</param>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.Program.MemoryObject">
            <summary>Generic memory object (buffer or image)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.MemoryObject.VarSize">
            <summary>Size of data to be stored</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.MemoryObject.OriginalVarLength">
            <summary>Original variable length</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.MemoryObject.VarPointer">
            <summary>Handle to memory object</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.MemoryObject.Dispose">
            <summary>Releases variable from memory.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.MemoryObject.Finalize">
            <summary>Destructor</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.MemoryObject.SetAsArgument(System.Int32,Cloo.ComputeKernel)">
            <summary>Sets this variable as an argument for a kernel</summary>
            <param name="ArgIndex">Index of kernel argument</param>
            <param name="Kernel">Kernel to receive argument</param>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.MemoryObject._CreatedFromGLBuffer">
            <summary>Was this memory Object created from a OpenGL buffer?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.MemoryObject._AcquiredInOpenCL">
            <summary>Was this buffer acquired in OpenCL?</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.Program.MemoryObject.Size">
            <summary>Returns the size of the stored variable</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.Program.MemoryObject.CreatedFromGLBuffer">
            <summary>Returns true if this Memory Object was created from an OpenGL buffer</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.Program.MemoryObject.AcquiredInOpenCL">
            <summary>Returns true if this Memory Object has been acquired for use in OpenCL (available for OpenCL)</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.Program.Variable">
            <summary>Variables class</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Type,System.Int32)">
            <summary>Creates a variable in the device memory without copying.</summary>            
            <param name="BufferType">Type of the buffer: typeof (int, float, double, long)</param>
            <param name="Count">Number of elements</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Int32,System.Type)">
            <summary>Creates variable from OpenGL buffer</summary>
            <param name="GLBuffer">Valid OpenGL Buffer</param>
            <param name="BufferType">Type of OpenGL Buffer: typeof (int, float, double, long)</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(Cloo.ComputeMemory,System.Int32,System.Int32)">
            <summary>Creates a OpenCLTemplate variable from a Cloo ComputeBuffer</summary>
            <param name="ClooMemoryObject">Cloo computebuffer to create from</param>
            <param name="Size">ClooMemoryObject.Size</param>
            <param name="Count">ClooMemoryObject.Count</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Single[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Int32[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Int16[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.UInt32[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Int64[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Double[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Char[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.#ctor(System.Byte[])">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Single[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Single[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Int32[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Int32[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Int16[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Int16[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.UInt32[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.UInt32[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Int64[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Int64[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Double[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Double[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Char[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Char[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Byte[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.WriteToDevice(System.Byte[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Single[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Single[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Int32[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Int32[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Int16[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Int16[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.UInt32[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.UInt32[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Int64[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Int64[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Double[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Double[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Char[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Char[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Byte[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Variable.ReadFromDeviceTo(System.Byte[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.Program.Image2D">
            <summary>Image2D class. Uses channel type RGBA.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.Image2D.width">
            <summary>Image width</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.Image2D.height">
            <summary>Image height</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.CLMalloc(System.Void*,Cloo.ComputeImageChannelType)">
            <summary>Unsafe allocation of memory</summary>
            <param name="p">Pointer to data</param>
            <param name="DataType">Data type: float, uint8 (byte), int32, etc.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.CLMalloc(Cloo.ComputeImageChannelType)">
            <summary>Allocation of empty memory</summary>
            <param name="DataType">Data type: float, uint8 (byte), int32, etc.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.#ctor(Cloo.ComputeImageChannelType,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="Type">Type that will be allocated in device memory. (Empty allocation)</param>
            <param name="Width">Image width.</param>
            <param name="Height">Image height.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.#ctor(System.Single[],System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
            <param name="Width">Image width.</param>
            <param name="Height">Image height.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.#ctor(System.Int32[],System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
            <param name="Width">Image width.</param>
            <param name="Height">Image height.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="Values">Variable whose size will be allocated in device memory.</param>
            <param name="Width">Image width.</param>
            <param name="Height">Image height.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.#ctor(System.Drawing.Bitmap)">
            <summary>Constructor. Remember, Bitmap uses the BGRA byte order.</summary>
            <param name="bmp">Bitmap to create OpenCL image from.</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.#ctor(System.Int32)">
            <summary>Constructor. Creates an image2d OpenCL object from a valid OpenCL texture. 
            IMPORTANT: The data type of this object from the HOST standpoint is BYTE in the Alpha Blue Green Red order.
            The data type in OpenCL is FLOAT4 (write_imagef) and in OpenGL the display order is BLUE GREEN RED ALPHA when modifying from OpenCL</summary>
            <param name="GLTextureBuffer">Valid OpenCL texture buffer to create image from</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteToDevice(System.Single[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteToDevice(System.Single[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteToDevice(System.Int32[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteToDevice(System.Int32[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteToDevice(System.Byte[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed writing.</param>
            <param name="events">OpenCL Event associated to this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteToDevice(System.Byte[])">
            <summary>Writes variable to device</summary>
            <param name="Values">Values to write to device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteBitmap(System.Drawing.Bitmap,Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Writes bitmap to device memory. Remember, Bitmap uses the BGRA byte order.</summary>
            <param name="bmp">Bitmap to write</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingWrite">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.WriteBitmap(System.Drawing.Bitmap)">
            <summary>Writes bitmap to device memory</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadFromDeviceTo(System.Single[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadFromDeviceTo(System.Single[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadFromDeviceTo(System.Int32[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadFromDeviceTo(System.Int32[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadFromDeviceTo(System.Byte[],Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads variable from device.</summary>
            <param name="Values">Values to store data coming from device</param>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadFromDeviceTo(System.Byte[])">
            <summary>Reads variable from device. Does not return until data has been copied.</summary>
            <param name="Values">Values to store data coming from device</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadBitmap(Cloo.ComputeCommandQueue,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Reads contents of device memory as bytes and writes bitmap. Remember, Bitmap uses the BGRA byte order.</summary>
            <param name="CQ">Command queue to use</param>
            <param name="BlockingRead">TRUE to return only after completed reading.</param>
            <param name="events">OpenCL Event associated with this operation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Image2D.ReadBitmap">
            <summary>Reads contents of device memory as bytes and writes bitmap</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.Program.Image2D.Width">
            <summary>Gets image2D width</summary>
        </member>
        <member name="P:OpenCLTemplate.CLCalc.Program.Image2D.Height">
            <summary>Gets image2D height</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.Program.Kernel">
            <summary>Kernels class</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.Kernel.kernel">
            <summary>Local kernel storage</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.#ctor(System.String)">
            <summary>Creates a new Kernel</summary>
            <param name="KernelName"></param>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.Program.Kernel.Vars">
            <summary>"Remember" variables</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.SetArguments(OpenCLTemplate.CLCalc.Program.MemoryObject[])">
            <summary>Sets kernel arguments</summary>
            <param name="Variables">Variables to be set as arguments</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(Cloo.ComputeCommandQueue,OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32[],System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Execute this kernel</summary>
            <param name="CQ">Command queue to use</param>
            <param name="Arguments">Arguments of the kernel function</param>
            <param name="GlobalWorkSize">Array of maximum index arrays. Total work-items = product(max[i],i+0..n-1), n=max.Length</param>
            <param name="events">Event of this command</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(Cloo.ComputeCommandQueue,OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32[],System.Int32[],System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Execute this kernel</summary>
            <param name="CQ">Command queue to use</param>
            <param name="Arguments">Arguments of the kernel function</param>
            <param name="GlobalWorkSize">Array of maximum index arrays. Total work-items = product(max[i],i+0..n-1), n=max.Length</param>
            <param name="LocalWorkSize">Local work sizes</param>
            <param name="events">Event of this command</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(Cloo.ComputeCommandQueue,OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32[],System.Int32[],System.Int32[],System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Execute this kernel</summary>
            <param name="CQ">Command queue to use</param>
            <param name="Arguments">Arguments of the kernel function</param>
            <param name="GlobalWorkSize">Array of maximum index arrays. Total work-items = product(max[i],i+0..n-1), n=max.Length</param>
            <param name="LocalWorkSize">Local work sizes</param>
            <param name="WorkOffSet">Global offset</param>
            <param name="events">Event of this command</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>Execute this kernel</summary>
            <param name="Arguments">Arguments of the kernel function</param>
            <param name="GlobalWorkSize">Array of maximum index arrays. Total work-items = product(max[i],i+0..n-1), n=max.Length</param>
            <param name="LocalWorkSize">Local work sizes</param>
            <param name="WorkOffSet">Global offset</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32[])">
            <summary>Execute this kernel</summary>
            <param name="GlobalWorkSize">Array of maximum index arrays. Total work-items = product(max[i],i+0..n-1), n=max.Length</param>
            <param name="Arguments">Arguments of the kernel function</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32)">
            <summary>Execute this kernel using work_dim = 1</summary>
            <param name="GlobalWorkSize">Global work size in one-dimension. global_work_size = new int[1] {GlobalWorkSize}</param>
            <param name="Arguments">Arguments of the kernel function</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32[],System.Int32[])">
            <summary>Execute this kernel</summary>
            <param name="GlobalWorkSize">Array of maximum index arrays. Total work-items = product(max[i],i+0..n-1), n=max.Length</param>
            <param name="LocalWorkSize">Local work sizes</param>
            <param name="Arguments">Arguments of the kernel function</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Execute(OpenCLTemplate.CLCalc.Program.MemoryObject[],System.Int32[],System.Int32[],System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
            <summary>Execute this kernel</summary>
            <param name="GlobalWorkSize">Array of maximum index arrays. Total work-items = product(max[i],i+0..n-1), n=max.Length</param>
            <param name="LocalWorkSize">Local work sizes</param>
            <param name="Arguments">Arguments of the kernel function</param>
            <param name="events">Events list</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Dispose">
            <summary>Releases kernel from memory</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.Program.Kernel.Finalize">
            <summary>Destructor</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.CLPrograms">
            <summary>OpenCL programs</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra">
            <summary>Basic linear algebra functions</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.floatVecSum">
            <summary>Float vector sum kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.floatMatrixMult">
            <summary>float matrix multiplication kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.floatGaussSeidel">
            <summary>float Gauss Seidel method</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.floatLUScale">
            <summary>LU factorizaton method</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.#ctor">
            <summary>Constructor. Builds OpenCL program.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.VectorToMatrix(System.Single[],System.Int32@,System.Int32@)">
            <summary>Converts vector to matrix</summary>
            <param name="v">Vector</param>
            <param name="maxi">Matrix first dimension</param>
            <param name="maxj">Matrix second dimension</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.MatrixToVector(System.Single[0:,0:],System.Int32@,System.Int32@)">
            <summary>Converts matrix to vector</summary>
            <param name="M">Matrix</param>
            <param name="maxi">Matrix first dimension</param>
            <param name="maxj">Matrix second dimension</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.MatrixSum(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>Returns the sum of two matrices</summary>
            <param name="M1">Matrix 1</param>
            <param name="M2">Matrix 2</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.MatrixMultiply(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>Matrix multiplication</summary>
            <param name="M1">Matrix 1</param>
            <param name="M2">Matrix 2</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.LeastSquaresGS(System.Single[0:,0:],System.Single[],System.Single[],System.Int32,System.Int32,System.Single,System.Single[]@)">
            <summary>Gauss Seidel method for iterative linear system solving. Returns unknown x</summary>
            <param name="M">Matrix M so that Mx=b</param>
            <param name="x">Initial estimate</param>
            <param name="b">Known vector b</param>
            <param name="Iterations">Gauss-Seidel iterations per step</param>
            <param name="MaxIter">Maximum number of times Gauss-Seidel iterations</param>
            <param name="totalError">Desired sqrt(Sum(error[i]^2))*number of equations</param>
            <param name="err">Estimated absolute error per component</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.LeastSquaresGS(System.Single[0:,0:],System.Single[],System.Single[],System.Single[]@)">
            <summary>Gauss Seidel method for iterative linear system solving. Returns unknown x</summary>
            <param name="M">Matrix M so that Mx=b</param>
            <param name="x">Initial estimate</param>
            <param name="b">Known vector b</param>
            <param name="err">Estimated error per equation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.LinSolve(System.Single[0:,0:],System.Single[],System.Single,System.Int32)">
            <summary>Solves linear system Mx = b by LU decomposition. Returns x</summary>
            <param name="M">Matrix M</param>
            <param name="b">Vector b</param>
            <param name="maxAbsErr">Maximum acceptable absolute error</param>
            <param name="maxIters">Maximum iterations</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.LUDecomp(System.Single[0:,0:],System.Int32,OpenCLTemplate.CLCalc.Program.Variable@)">
            <summary>Calculates LU decomposition of M matrix</summary>
            <param name="M">Matrix to decompose</param>
            <param name="n">Matrix dimension</param>
            <param name="varindx">Swap index</param>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.LinalgSource.GaussSeidel">
            <summary>Gauss Seidel method. Make sure to send x = b. Replaces x.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatLinearAlgebra.LinalgSource.matrixMult">
            <summary>Matrix multiplication. Dimensions { p, r }.
            </summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra">
            <summary>Basic linear algebra functions</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.doubleVecSum">
            <summary>Float vector sum kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.doubleMatrixMult">
            <summary>double matrix multiplication kernel</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.doubleGaussSeidel">
            <summary>double Gauss Seidel method</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.doubleLUScale">
            <summary>LU factorizaton method</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.#ctor">
            <summary>Constructor. Builds OpenCL program.</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.VectorToMatrix(System.Double[],System.Int32@,System.Int32@)">
            <summary>Converts vector to matrix</summary>
            <param name="v">Vector</param>
            <param name="maxi">Matrix first dimension</param>
            <param name="maxj">Matrix second dimension</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.MatrixToVector(System.Double[0:,0:],System.Int32@,System.Int32@)">
            <summary>Converts matrix to vector</summary>
            <param name="M">Matrix</param>
            <param name="maxi">Matrix first dimension</param>
            <param name="maxj">Matrix second dimension</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.MatrixSum(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Returns the sum of two matrices</summary>
            <param name="M1">Matrix 1</param>
            <param name="M2">Matrix 2</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.MatrixMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Matrix multiplication</summary>
            <param name="M1">Matrix 1</param>
            <param name="M2">Matrix 2</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.LeastSquaresGS(System.Double[0:,0:],System.Double[],System.Double[],System.Int32,System.Int32,System.Double,System.Double[]@)">
            <summary>Gauss Seidel method for iterative linear system solving. Returns unknown x</summary>
            <param name="M">Matrix M so that Mx=b</param>
            <param name="x">Initial estimate</param>
            <param name="b">Known vector b</param>
            <param name="Iterations">Gauss-Seidel iterations per step</param>
            <param name="MaxIter">Maximum number of times Gauss-Seidel iterations</param>
            <param name="totalError">Desired sqrt(Sum(error[i]^2))*number of equations</param>
            <param name="err">Estimated absolute error per component</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.LeastSquaresGS(System.Double[0:,0:],System.Double[],System.Double[],System.Double[]@)">
            <summary>Gauss Seidel method for iterative linear system solving. Returns unknown x</summary>
            <param name="M">Matrix M so that Mx=b</param>
            <param name="x">Initial estimate</param>
            <param name="b">Known vector b</param>
            <param name="err">Estimated error per equation</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.LinSolve(System.Double[0:,0:],System.Double[],System.Double,System.Int32)">
            <summary>Solves linear system Mx = b by LU decomposition. Returns x</summary>
            <param name="M">Matrix M</param>
            <param name="b">Vector b</param>
            <param name="maxAbsErr">Maximum acceptable absolute error</param>
            <param name="maxIters">Maximum iterations</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.LUDecomp(System.Double[0:,0:],System.Int32,OpenCLTemplate.CLCalc.Program.Variable@)">
            <summary>Calculates LU decomposition of M matrix</summary>
            <param name="M">Matrix to decompose</param>
            <param name="n">Matrix dimension</param>
            <param name="varindx">Swap index</param>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.LinalgSource.GaussSeidel">
            <summary>Gauss Seidel method. Make sure to send x = b. Replaces x.</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.doubleLinearAlgebra.LinalgSource.matrixMult">
            <summary>Matrix multiplication. Dimensions { p, r }.
            </summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.CLPrograms.floatDEM">
            <summary>Discrete element modeling. Calculates derivatives of n particle-spring model into a 6n space-state
            system (positions, velocities, x,y,z each).</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.m">
            <summary>Mass values (n)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.posOrig">
            <summary>Original positions (3n)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.origs">
            <summary>Origins (L) origs[i] connects to dests[i]</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.dests">
            <summary>Destinations (L)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.k">
            <summary>Spring constants (L)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.kGround">
            <summary>Spring constants to ground (n)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.c">
            <summary>Damping (L)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.cGround">
            <summary>Damping to ground (n)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.nConnec">
            <summary>Number of Connections (1)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.L0">
            <summary>Initial distances (L)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.forces">
            <summary>Actuating forces (3*n)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.connForces">
            <summary>Connection forces (L)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.nodesConnections">
            <summary>Nodes connections (int, 20*n)</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.KernelcalcL0">
            <summary>Initial lengths kernel. work_dim = 1, globalsize = n</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.argscalcL0">
            <summary>Initial length arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.KernelresetForces">
            <summary>Reset forces kernel. work_dim = 1, globalsize = 3n</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.argsresetForces">
            <summary>Reset forces arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.KernelcalcForces">
            <summary>Calculate forces kernel. work_dim = 1, globalsize = L</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.argscalcForces">
            <summary>Calculate forces arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.KernelcalcGroundForces">
            <summary>Calculate forces kernel. work_dim = 1, globalsize = n</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.argscalcGroundForces">
            <summary>Calculate forces arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.Kernelderivs">
            <summary>Calculate forces kernel. work_dim = 1, globalsize = L</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.argsderivs">
            <summary>Calculate forces arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.KernelcalcNodesConnections">
            <summary>Calculate nodes connections. work_dim = 1, globalsize = n</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.argscalcNodesConnections">
            <summary>Calculate nodes connections arguments</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.#ctor(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>Constructor.</summary>
            <param name="nMasses">Number of masses in the system</param>
            <param name="nConnections">Number of connections</param>
            <param name="Masses">Mass of each vertex</param>
            <param name="InitialStateSpace">Position and velocity of vertexes 
            [2*3*i] - posx, [2*(3*i+1)] - posy, [2*(3*i+2)] - posz, 
            [1+2*3*i] - velx, [1+2*(3*i+1)] - vely, [1+2*(3*i+2)] - velz</param>
            <param name="Origins">Origin vertex of connections. Spring connects Origin[i] to Dests[i]</param>
            <param name="Dests">Destination vertex of connections. Spring connects Origin[i] to Dests[i]</param>
            <param name="SpringKs">Spring constant for each connection</param>
            <param name="GroundKs">Spring constant for each mass, connecting to ground (nMass)</param>
            <param name="Damp">Structural damping (relative-speed dependant) (nConnections)</param>
            <param name="GroundDamp">Absolute damping proportional to speed relative to Earth (nMass)</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.derivs(OpenCLTemplate.CLCalc.Program.Variable,OpenCLTemplate.CLCalc.Program.Variable,OpenCLTemplate.CLCalc.Program.Variable)">
            <summary>Calculates derivatives of deformable body space-state vector dydx[6n]. dydx[2i] - i-th position deriv, 
            dydx[2i+1] - ith velocity deriv</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.DEMSource.floatresetForces">
            <summary>Reset forces. Work_dim = 1, nmax = { nMasses }</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.DEMSource.derivs(System.Single[],System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>Derivatives sketch. Work_dim = 1, nmax = { 3 * nMasses }</summary>
            <param name="forces">Forces</param>
            <param name="masses">Masses</param>
            <param name="x">Independent variable</param>
            <param name="y">State space vector</param>
            <param name="dydx">Derivatives</param>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.DEMSource.floatcalcL0">
            <summary>Initial L0 calculation. work_dim = 1, global_work_size[0]=nConnections</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.DEMSource.floatcalcForces">
            <summary>Forces calculation. Returns forces. Work_dim = 1, nmax = { nConnections }</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.DEMSource.floatcalcGroundForces">
            <summary>Calculates forces to ground. w_dim=1, global_work_size = nMasses</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatDEM.DEMSource.floatcalcNodesConnections">
            <summary>Calculates forces to ground. w_dim=1, global_work_size = nMasses</summary>
        </member>
        <member name="T:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics">
            <summary>Floating point particle system physics</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.ConstAccelMotionEDOSolver">
            <summary>Motion Newton-law 1D solver. Kernel: rk46</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.ForceAppliers">
            <summary>Force applier to particles. Kernels: ResetForces, ApplyGravity, FloorCollision</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.CollisionAppliers">
            <summary>Collision applier to particles. Kernels: ResetForces, ApplyGravity, FloorCollision</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.#ctor(System.Int32)">
            <summary>Initializes physics program. Components indexes: [i] - x, [i+1] - y, [i+2] - z</summary>
            <param name="nParticles">Number of particles</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.SetParams(System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>Sets particles parameters</summary>
            <param name="pos">Positions (3*numParticles)</param>
            <param name="vel">Speeds (3*numParticles)</param>
            <param name="mass">Masses (numParticles)</param>
            <param name="collisionSizes">Collision sizes (numParticles)</param>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.GetPositions">
            <summary>Gets particles positions</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.GetCloseNeighbors">
            <summary>Gets how many close neighbors a particle has. Use this to avoid drawing unnecessary particles</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.GetTime">
            <summary>Gets simulation time</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.step">
            <summary>Stepsize</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.MotionStep">
            <summary>Executes an integration step</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.stepArgs">
            <summary>Motion step arguments</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.Step(System.Single)">
            <summary>Takes an integration step</summary>
            <param name="stepSize">Step size</param>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.Kernel_ApplyGravity">
            <summary>Applies gravity</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.applyGravArgs">
            <summary>Apply gravity arguments</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.ApplyGravity(System.Single[])">
            <summary>Applies gravity force.</summary>
            <param name="value">Gravity force. Remember to use negative for down direction.</param>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.Kernel_ResetForces">
            <summary>Clear forces</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.resetForcesArgs">
            <summary>Apply gravity arguments</summary>
        </member>
        <member name="M:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.ResetForces">
            <summary>Clears forces</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.Kernel_FloorCollision">
            <summary>Floor collision</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.floorCollisionArgs">
            <summary>Apply floor collision arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.EnableFloorCollision">
            <summary>Applies floor collision?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.Kernel_WallCollision">
            <summary>Wall collision</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.wallCollisionArgs">
            <summary>Apply floor collision arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.EnableWallCollision">
            <summary>Applies floor collision?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.Kernel_SelfCollision">
            <summary>Self collision</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.selfCollisionArgs">
            <summary>Apply self collision arguments</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.EnableSelfCollision">
            <summary>Applies self collision?</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.Kernel_ResetCloseNeighbors">
            <summary>Reset close neighbors</summary>
        </member>
        <member name="F:OpenCLTemplate.CLCalc.CLPrograms.floatBodyPhysics.resetCloseNeighborsArgs">
            <summary>Apply self collision arguments</summary>
        </member>
        <member name="T:OpenCLTemplate.OMR.CLSuperPixel">
            <summary>Superpixel analysis class</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.MAXITERCOLORPROPAGATION">
            <summary>Maximum number of iterations during color propagation</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.MINNUMBEROFPIXELSPERREGION">
            <summary>Minimum number of pixels per color region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.STDDEVTOLERANCETOCONSIDERNEIGHBOR">
            <summary>Tolerance in standard deviation to consider pixel groups as neighbors</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.USESOBELBORDER">
            <summary>Use Sobel border instead of variance border?</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.USEMEDIANFILTER">
            <summary>Use Median filter? May not be necessary with a good camera</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.USEBLURFILTER">
            <summary>Use Blur filter?</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.NBORDERPIXELS">
            <summary>Number of pixels in border (typical)</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.AREAPERIMETERTOLERANCE">
            <summary>Tolerance in area max - min difference: min * AREAPERIMETERTOLERANCE more than max </summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.MINPERCENTREGIONSTOCONSIDERCHECKERBOARD">
            <summary>Minimum number of internal squares to consider a region as checkerboard</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CONCENTRICREGIONDISTTOL">
            <summary>Tolerance in center distance to consider as concentric region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CONCENTRICREGIONRADIUSTOL">
            <summary>Tolerance in radius difference to consider as concentric region</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.#cctor">
            <summary>Static constructor.</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLbmp">
            <summary>Bitmap in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLbmpAux">
            <summary>Bitmap in CL memory</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLsuperPixelList">
            <summary>List of pixels categorized as belonging to the same group</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLPixStdDev">
            <summary>Standard deviation of pixel values - image border intensity</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLbmpDim">
            <summary>Bitmap dimensions</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLChanged">
            <summary>Has assignment been changed?</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLColors">
            <summary>Simple list of colors to apply in visual representation of cluster</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLPixelCoords">
            <summary>Pixel coordinates of a given color region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLPixelColors">
            <summary>Pixel colors</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.CLPixelNeighbors">
            <summary>Pixel neighborhood to check for boundary pixels</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.regionDrawColors">
            <summary>Colors to use to draw regions</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.#ctor(System.Drawing.Bitmap)">
            <summary>Creates a new superpixel analyzer using Bitmap dimensions</summary>
            <param name="bmp">Bitmap to use</param>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel._regionData">
            <summary>Contiguous regions found in image</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.initBmp(System.Drawing.Bitmap)">
            <summary>Initializes variables based on Bitmap</summary>
            <param name="bmp">Reference bitmap</param>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.SetBmp(System.Drawing.Bitmap)">
            <summary>Sets a new bitmap to be analyzed. Returns image representation of clusterization</summary>
            <param name="bmp">New bitmap</param>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.FindTargets(System.Int32)">
            <summary>Finds targets inside image. Targets are concentric regions of the same color in the image.
            Reference image: bullseye target</summary>
            <param name="minConcentricRegions">Minimum number of concentric regions</param>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.FindNeighborhood">
            <summary>Determines neighborhoods of regions</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.FindCheckerboards(System.Collections.Generic.List{System.Collections.Generic.List{OpenCLTemplate.OMR.CLSuperPixel.RegionData}})">
            <summary>Finds checkerboards in the image, from 7x5 to 19x19. Returns index information of regions</summary>
            <param name="neighborhood">Neighborhood information</param>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.GetSquareCoordinates(System.Int32,System.Int32,System.Collections.Generic.List{OpenCLTemplate.OMR.CLSuperPixel.RegionData},System.Collections.Generic.List{System.Drawing.PointF},System.Boolean)">
            <summary>Attempts to assign positions in the checkerboard to each region. Returns assigned positions
            or NULL if invalid checkerboard</summary>
            <param name="n">Number of squares in width</param>
            <param name="m">Number of squares in height</param>
            <param name="region">Region to analyze</param>
            <param name="quad">4 point approximation of Polygon</param>
            <param name="BlackSquaresOnly">Will regions contain only black squares? (false for a regular checkerboard)</param>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.MidPoint(System.Drawing.PointF,System.Drawing.PointF,System.Single)">
            <summary>Computes A + alpha*AB</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.SquaresInCheckerboard">
            <summary>Possible number of squares in checkerboard</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.initSquaresInCheckerboard">
            <summary>Initializes squares in checkerboard list</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.GetColorRegionIdentification(System.Boolean,System.Boolean)">
            <summary>Retrieves color region identification. Use Setbmp first to process bitmap</summary>
            <param name="DrawUniqueColors">Redraw image using unique colors. Set to false to draw on top of original image</param>
            <param name="DrawPixelMeanDists">Redraw image drawing circles to represent pixel distances</param>
            <returns></returns>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.Sobel(System.Drawing.Bitmap)">
            <summary>Finds image borders using Sobel filter</summary>
            <param name="bmp">Bitmap to process</param>
            <returns></returns>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.PixelVariance(System.Drawing.Bitmap)">
            <summary>Finds image borders using Sobel filter</summary>
            <param name="bmp">Bitmap to process</param>
            <returns></returns>
        </member>
        <member name="T:OpenCLTemplate.OMR.CLSuperPixel.RegionData">
            <summary>Stores relevant region information</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.colorID">
            <summary>Color ID of region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.Pixels">
            <summary>Pixels -> [x0 y0 x1 y1 ...</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.Colors">
            <summary>Colors -> [r1 g1 b1 r2 g2 b2 ...</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.Center">
            <summary>Region center [0] - X, [1] - Y</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.Color">
            <summary>Region mean color</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.meanDistToCenter">
            <summary>Average distance of pixels to center</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.stdDevDistToCenter">
            <summary>Standard deviation of pixel distance to center</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.Area">
            <summary>Area and perimeter of region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.Perimeter">
            <summary>Area and perimeter of region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.RegionData.Connections">
            <summary>Which regions are connected to this one?</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.RegionData.ToString">
            <summary>String representation</summary>
            <returns></returns>
        </member>
        <member name="T:OpenCLTemplate.OMR.CLSuperPixel.ConcentricRegionInfo">
            <summary>Stores concentric region information</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.ConcentricRegionInfo.#ctor(System.Collections.Generic.List{OpenCLTemplate.OMR.CLSuperPixel.RegionData})">
            <summary>Creates new concentric region information</summary>
            <param name="cr">Region data of concentric region constituents</param>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.ConcentricRegionInfo.ToString">
            <summary>String representation</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.ConcentricRegionInfo.CenterX">
            <summary>X coord of concentric region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.ConcentricRegionInfo.CenterY">
            <summary>Y coord of concentric region</summary>
        </member>
        <member name="F:OpenCLTemplate.OMR.CLSuperPixel.ConcentricRegionInfo.ID">
            <summary>String ID of this region</summary>
        </member>
        <member name="M:OpenCLTemplate.OMR.CLSuperPixel.ConcentricRegionInfo.GetID(System.Collections.Generic.List{OpenCLTemplate.OMR.CLSuperPixel.RegionData})">
            <summary>Gets string ID from concentric region data</summary>
            <param name="cr">Concentric region</param>
        </member>
    </members>
</doc>
